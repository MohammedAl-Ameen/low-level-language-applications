CCS PCM C Compiler, Version 5.049, 5967               30-Oct-20 21:42

               Filename:   C:\Users\mohmmed\Desktop\Task3\Part2\Code\Task3.lst

               ROM used:   3309 words (40%)
                           Largest free fragment is 2048
               RAM used:   96 (26%) at main() level
                           133 (36%) worst case
               Stack used: 4 locations
               Stack size: 8

*
0000:  MOVLW  0A
0001:  MOVWF  0A
0002:  GOTO   26B
0003:  NOP
.................... #include<16f877a.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDLW  0B
0008:  BTFSC  03.0
0009:  INCF   0A,F
000A:  MOVWF  02
000B:  RETLW  00
000C:  RETLW  00
000D:  RETLW  00
000E:  RETLW  00
000F:  RETLW  00
0010:  RETLW  00
0011:  RETLW  00
0012:  RETLW  5F
0013:  RETLW  00
0014:  RETLW  00
0015:  RETLW  00
0016:  RETLW  03
0017:  RETLW  00
0018:  RETLW  03
0019:  RETLW  00
001A:  RETLW  14
001B:  RETLW  3E
001C:  RETLW  14
001D:  RETLW  3E
001E:  RETLW  14
001F:  RETLW  24
0020:  RETLW  2A
0021:  RETLW  7F
0022:  RETLW  2A
0023:  RETLW  12
0024:  RETLW  43
0025:  RETLW  33
0026:  RETLW  08
0027:  RETLW  66
0028:  RETLW  61
0029:  RETLW  36
002A:  RETLW  49
002B:  RETLW  55
002C:  RETLW  22
002D:  RETLW  50
002E:  RETLW  00
002F:  RETLW  05
0030:  RETLW  03
0031:  RETLW  00
0032:  RETLW  00
0033:  RETLW  00
0034:  RETLW  1C
0035:  RETLW  22
0036:  RETLW  41
0037:  RETLW  00
0038:  RETLW  00
0039:  RETLW  41
003A:  RETLW  22
003B:  RETLW  1C
003C:  RETLW  00
003D:  RETLW  14
003E:  RETLW  08
003F:  RETLW  3E
0040:  RETLW  08
0041:  RETLW  14
0042:  RETLW  08
0043:  RETLW  08
0044:  RETLW  3E
0045:  RETLW  08
0046:  RETLW  08
0047:  RETLW  00
0048:  RETLW  50
0049:  RETLW  30
004A:  RETLW  00
004B:  RETLW  00
004C:  RETLW  08
004D:  RETLW  08
004E:  RETLW  08
004F:  RETLW  08
0050:  RETLW  08
0051:  RETLW  00
0052:  RETLW  60
0053:  RETLW  60
0054:  RETLW  00
0055:  RETLW  00
0056:  RETLW  20
0057:  RETLW  10
0058:  RETLW  08
0059:  RETLW  04
005A:  RETLW  02
005B:  RETLW  3E
005C:  RETLW  51
005D:  RETLW  49
005E:  RETLW  45
005F:  RETLW  3E
0060:  RETLW  00
0061:  RETLW  04
0062:  RETLW  02
0063:  RETLW  7F
0064:  RETLW  00
0065:  RETLW  42
0066:  RETLW  61
0067:  RETLW  51
0068:  RETLW  49
0069:  RETLW  46
006A:  RETLW  22
006B:  RETLW  41
006C:  RETLW  49
006D:  RETLW  49
006E:  RETLW  36
006F:  RETLW  18
0070:  RETLW  14
0071:  RETLW  12
0072:  RETLW  7F
0073:  RETLW  10
0074:  RETLW  27
0075:  RETLW  45
0076:  RETLW  45
0077:  RETLW  45
0078:  RETLW  39
0079:  RETLW  3E
007A:  RETLW  49
007B:  RETLW  49
007C:  RETLW  49
007D:  RETLW  32
007E:  RETLW  01
007F:  RETLW  01
0080:  RETLW  71
0081:  RETLW  09
0082:  RETLW  07
0083:  RETLW  36
0084:  RETLW  49
0085:  RETLW  49
0086:  RETLW  49
0087:  RETLW  36
0088:  RETLW  26
0089:  RETLW  49
008A:  RETLW  49
008B:  RETLW  49
008C:  RETLW  3E
008D:  RETLW  00
008E:  RETLW  36
008F:  RETLW  36
0090:  RETLW  00
0091:  RETLW  00
0092:  RETLW  00
0093:  RETLW  56
0094:  RETLW  36
0095:  RETLW  00
0096:  RETLW  00
0097:  RETLW  08
0098:  RETLW  14
0099:  RETLW  22
009A:  RETLW  41
009B:  RETLW  00
009C:  RETLW  14
009D:  RETLW  14
009E:  RETLW  14
009F:  RETLW  14
00A0:  RETLW  14
00A1:  RETLW  00
00A2:  RETLW  41
00A3:  RETLW  22
00A4:  RETLW  14
00A5:  RETLW  08
00A6:  RETLW  02
00A7:  RETLW  01
00A8:  RETLW  51
00A9:  RETLW  09
00AA:  RETLW  06
00AB:  RETLW  3E
00AC:  RETLW  41
00AD:  RETLW  59
00AE:  RETLW  55
00AF:  RETLW  5E
00B0:  RETLW  7E
00B1:  RETLW  09
00B2:  RETLW  09
00B3:  RETLW  09
00B4:  RETLW  7E
00B5:  RETLW  7F
00B6:  RETLW  49
00B7:  RETLW  49
00B8:  RETLW  49
00B9:  RETLW  36
00BA:  RETLW  3E
00BB:  RETLW  41
00BC:  RETLW  41
00BD:  RETLW  41
00BE:  RETLW  22
00BF:  RETLW  7F
00C0:  RETLW  41
00C1:  RETLW  41
00C2:  RETLW  41
00C3:  RETLW  3E
00C4:  RETLW  7F
00C5:  RETLW  49
00C6:  RETLW  49
00C7:  RETLW  49
00C8:  RETLW  41
00C9:  RETLW  7F
00CA:  RETLW  09
00CB:  RETLW  09
00CC:  RETLW  09
00CD:  RETLW  01
00CE:  RETLW  3E
00CF:  RETLW  41
00D0:  RETLW  41
00D1:  RETLW  49
00D2:  RETLW  3A
00D3:  RETLW  7F
00D4:  RETLW  08
00D5:  RETLW  08
00D6:  RETLW  08
00D7:  RETLW  7F
00D8:  RETLW  00
00D9:  RETLW  41
00DA:  RETLW  7F
00DB:  RETLW  41
00DC:  RETLW  00
00DD:  RETLW  30
00DE:  RETLW  40
00DF:  RETLW  40
00E0:  RETLW  40
00E1:  RETLW  3F
00E2:  RETLW  7F
00E3:  RETLW  08
00E4:  RETLW  14
00E5:  RETLW  22
00E6:  RETLW  41
00E7:  RETLW  7F
00E8:  RETLW  40
00E9:  RETLW  40
00EA:  RETLW  40
00EB:  RETLW  40
00EC:  RETLW  7F
00ED:  RETLW  02
00EE:  RETLW  0C
00EF:  RETLW  02
00F0:  RETLW  7F
00F1:  RETLW  7F
00F2:  RETLW  02
00F3:  RETLW  04
00F4:  RETLW  08
00F5:  RETLW  7F
00F6:  RETLW  3E
00F7:  RETLW  41
00F8:  RETLW  41
00F9:  RETLW  41
00FA:  RETLW  3E
00FB:  RETLW  7F
00FC:  RETLW  09
00FD:  RETLW  09
00FE:  RETLW  09
00FF:  RETLW  06
0100:  RETLW  1E
0101:  RETLW  21
0102:  RETLW  21
0103:  RETLW  21
0104:  RETLW  5E
0105:  RETLW  7F
0106:  RETLW  09
0107:  RETLW  09
0108:  RETLW  09
0109:  RETLW  76
010A:  BSF    0A.0
010B:  BCF    0A.1
010C:  BCF    0A.2
010D:  ADDWF  02,F
010E:  RETLW  26
010F:  RETLW  49
0110:  RETLW  49
0111:  RETLW  49
0112:  RETLW  32
0113:  RETLW  01
0114:  RETLW  01
0115:  RETLW  7F
0116:  RETLW  01
0117:  RETLW  01
0118:  RETLW  3F
0119:  RETLW  40
011A:  RETLW  40
011B:  RETLW  40
011C:  RETLW  3F
011D:  RETLW  1F
011E:  RETLW  20
011F:  RETLW  40
0120:  RETLW  20
0121:  RETLW  1F
0122:  RETLW  7F
0123:  RETLW  20
0124:  RETLW  10
0125:  RETLW  20
0126:  RETLW  7F
0127:  RETLW  41
0128:  RETLW  22
0129:  RETLW  1C
012A:  RETLW  22
012B:  RETLW  41
012C:  RETLW  07
012D:  RETLW  08
012E:  RETLW  70
012F:  RETLW  08
0130:  RETLW  07
0131:  RETLW  61
0132:  RETLW  51
0133:  RETLW  49
0134:  RETLW  45
0135:  RETLW  43
0136:  RETLW  00
0137:  RETLW  7F
0138:  RETLW  41
0139:  RETLW  00
013A:  RETLW  00
013B:  RETLW  02
013C:  RETLW  04
013D:  RETLW  08
013E:  RETLW  10
013F:  RETLW  20
0140:  RETLW  00
0141:  RETLW  00
0142:  RETLW  41
0143:  RETLW  7F
0144:  RETLW  00
0145:  RETLW  04
0146:  RETLW  02
0147:  RETLW  01
0148:  RETLW  02
0149:  RETLW  04
014A:  RETLW  40
014B:  RETLW  40
014C:  RETLW  40
014D:  RETLW  40
014E:  RETLW  40
014F:  RETLW  00
0150:  RETLW  01
0151:  RETLW  02
0152:  RETLW  04
0153:  RETLW  00
0154:  RETLW  20
0155:  RETLW  54
0156:  RETLW  54
0157:  RETLW  54
0158:  RETLW  78
0159:  RETLW  7F
015A:  RETLW  44
015B:  RETLW  44
015C:  RETLW  44
015D:  RETLW  38
015E:  RETLW  38
015F:  RETLW  44
0160:  RETLW  44
0161:  RETLW  44
0162:  RETLW  44
0163:  RETLW  38
0164:  RETLW  44
0165:  RETLW  44
0166:  RETLW  44
0167:  RETLW  7F
0168:  RETLW  38
0169:  RETLW  54
016A:  RETLW  54
016B:  RETLW  54
016C:  RETLW  18
016D:  RETLW  04
016E:  RETLW  04
016F:  RETLW  7E
0170:  RETLW  05
0171:  RETLW  05
0172:  RETLW  08
0173:  RETLW  54
0174:  RETLW  54
0175:  RETLW  54
0176:  RETLW  3C
0177:  RETLW  7F
0178:  RETLW  08
0179:  RETLW  04
017A:  RETLW  04
017B:  RETLW  78
017C:  RETLW  00
017D:  RETLW  44
017E:  RETLW  7D
017F:  RETLW  40
0180:  RETLW  00
0181:  RETLW  20
0182:  RETLW  40
0183:  RETLW  44
0184:  RETLW  3D
0185:  RETLW  00
0186:  RETLW  7F
0187:  RETLW  10
0188:  RETLW  28
0189:  RETLW  44
018A:  RETLW  00
018B:  RETLW  00
018C:  RETLW  41
018D:  RETLW  7F
018E:  RETLW  40
018F:  RETLW  00
0190:  RETLW  7C
0191:  RETLW  04
0192:  RETLW  78
0193:  RETLW  04
0194:  RETLW  78
0195:  RETLW  7C
0196:  RETLW  08
0197:  RETLW  04
0198:  RETLW  04
0199:  RETLW  78
019A:  RETLW  38
019B:  RETLW  44
019C:  RETLW  44
019D:  RETLW  44
019E:  RETLW  38
019F:  RETLW  7C
01A0:  RETLW  14
01A1:  RETLW  14
01A2:  RETLW  14
01A3:  RETLW  08
01A4:  RETLW  08
01A5:  RETLW  14
01A6:  RETLW  14
01A7:  RETLW  14
01A8:  RETLW  7C
01A9:  RETLW  00
01AA:  RETLW  7C
01AB:  RETLW  08
01AC:  RETLW  04
01AD:  RETLW  04
01AE:  RETLW  48
01AF:  RETLW  54
01B0:  RETLW  54
01B1:  RETLW  54
01B2:  RETLW  20
01B3:  RETLW  04
01B4:  RETLW  04
01B5:  RETLW  3F
01B6:  RETLW  44
01B7:  RETLW  44
01B8:  RETLW  3C
01B9:  RETLW  40
01BA:  RETLW  40
01BB:  RETLW  20
01BC:  RETLW  7C
01BD:  RETLW  1C
01BE:  RETLW  20
01BF:  RETLW  40
01C0:  RETLW  20
01C1:  RETLW  1C
01C2:  RETLW  3C
01C3:  RETLW  40
01C4:  RETLW  30
01C5:  RETLW  40
01C6:  RETLW  3C
01C7:  RETLW  44
01C8:  RETLW  28
01C9:  RETLW  10
01CA:  RETLW  28
01CB:  RETLW  44
01CC:  RETLW  0C
01CD:  RETLW  50
01CE:  RETLW  50
01CF:  RETLW  50
01D0:  RETLW  3C
01D1:  RETLW  44
01D2:  RETLW  64
01D3:  RETLW  54
01D4:  RETLW  4C
01D5:  RETLW  44
01D6:  RETLW  00
01D7:  RETLW  08
01D8:  RETLW  36
01D9:  RETLW  41
01DA:  RETLW  41
01DB:  RETLW  00
01DC:  RETLW  00
01DD:  RETLW  7F
01DE:  RETLW  00
01DF:  RETLW  00
01E0:  RETLW  41
01E1:  RETLW  41
01E2:  RETLW  36
01E3:  RETLW  08
01E4:  RETLW  00
01E5:  RETLW  02
01E6:  RETLW  01
01E7:  RETLW  02
01E8:  RETLW  04
01E9:  RETLW  02
*
0215:  CLRF   77
0216:  CLRF   78
0217:  BSF    03.5
0218:  MOVF   31,W
0219:  BCF    03.0
021A:  BTFSC  32.0
021B:  ADDWF  77,F
021C:  RRF    77,F
021D:  RRF    78,F
021E:  BTFSC  32.1
021F:  ADDWF  77,F
0220:  RRF    77,F
0221:  RRF    78,F
0222:  BTFSC  32.2
0223:  ADDWF  77,F
0224:  RRF    77,F
0225:  RRF    78,F
0226:  BTFSC  32.3
0227:  ADDWF  77,F
0228:  RRF    77,F
0229:  RRF    78,F
022A:  BTFSC  32.4
022B:  ADDWF  77,F
022C:  RRF    77,F
022D:  RRF    78,F
022E:  BTFSC  32.5
022F:  ADDWF  77,F
0230:  RRF    77,F
0231:  RRF    78,F
0232:  BTFSC  32.6
0233:  ADDWF  77,F
0234:  RRF    77,F
0235:  RRF    78,F
0236:  BTFSC  32.7
0237:  ADDWF  77,F
0238:  RRF    77,F
0239:  RRF    78,F
023A:  BCF    03.5
023B:  RETURN
*
05D9:  MOVLW  8E
05DA:  MOVWF  77
05DB:  BSF    03.5
05DC:  MOVF   23,W
05DD:  MOVWF  78
05DE:  MOVF   22,W
05DF:  MOVWF  79
05E0:  CLRF   7A
05E1:  MOVF   78,F
05E2:  BTFSS  03.2
05E3:  GOTO   5EE
05E4:  MOVF   79,W
05E5:  MOVWF  78
05E6:  CLRF   79
05E7:  MOVLW  08
05E8:  SUBWF  77,F
05E9:  MOVF   78,F
05EA:  BTFSS  03.2
05EB:  GOTO   5EE
05EC:  CLRF   77
05ED:  GOTO   5F6
05EE:  BCF    03.0
05EF:  BTFSC  78.7
05F0:  GOTO   5F5
05F1:  RLF    79,F
05F2:  RLF    78,F
05F3:  DECF   77,F
05F4:  GOTO   5EE
05F5:  BCF    78.7
05F6:  BCF    03.5
05F7:  BSF    0A.3
05F8:  BCF    0A.4
05F9:  GOTO   30E (RETURN)
05FA:  BSF    03.5
05FB:  MOVF   2D,W
05FC:  BTFSC  03.2
05FD:  GOTO   66B
05FE:  MOVWF  35
05FF:  MOVF   31,W
0600:  BTFSC  03.2
0601:  GOTO   66B
0602:  ADDWF  35,F
0603:  BTFSC  03.0
0604:  GOTO   60C
0605:  MOVLW  7F
0606:  SUBWF  35,F
0607:  BTFSS  03.0
0608:  GOTO   66B
0609:  BTFSC  03.2
060A:  GOTO   66B
060B:  GOTO   610
060C:  MOVLW  81
060D:  ADDWF  35,F
060E:  BTFSC  03.0
060F:  GOTO   66B
0610:  MOVF   35,W
0611:  MOVWF  77
0612:  CLRF   78
0613:  CLRF   79
0614:  CLRF   7A
0615:  MOVF   2E,W
0616:  MOVWF  39
0617:  BSF    39.7
0618:  MOVF   2F,W
0619:  MOVWF  38
061A:  MOVF   30,W
061B:  MOVWF  37
061C:  MOVLW  18
061D:  MOVWF  35
061E:  CLRF   36
061F:  BTFSS  37.0
0620:  GOTO   639
0621:  MOVF   34,W
0622:  ADDWF  7A,F
0623:  BTFSS  03.0
0624:  GOTO   62B
0625:  INCF   79,F
0626:  BTFSS  03.2
0627:  GOTO   62B
0628:  INCF   78,F
0629:  BTFSC  03.2
062A:  BSF    36.7
062B:  MOVF   33,W
062C:  ADDWF  79,F
062D:  BTFSS  03.0
062E:  GOTO   632
062F:  INCF   78,F
0630:  BTFSC  03.2
0631:  BSF    36.7
0632:  MOVF   32,W
0633:  MOVWF  2F
0634:  BSF    2F.7
0635:  MOVF   2F,W
0636:  ADDWF  78,F
0637:  BTFSC  03.0
0638:  BSF    36.7
0639:  RLF    36,F
063A:  RRF    78,F
063B:  RRF    79,F
063C:  RRF    7A,F
063D:  RRF    39,F
063E:  RRF    38,F
063F:  RRF    37,F
0640:  BCF    03.0
0641:  DECFSZ 35,F
0642:  GOTO   61E
0643:  MOVLW  01
0644:  ADDWF  77,F
0645:  BTFSC  03.0
0646:  GOTO   66B
0647:  BTFSC  78.7
0648:  GOTO   650
0649:  RLF    39,F
064A:  RLF    7A,F
064B:  RLF    79,F
064C:  RLF    78,F
064D:  DECF   77,F
064E:  BTFSC  03.2
064F:  GOTO   66B
0650:  BTFSS  39.7
0651:  GOTO   661
0652:  INCF   7A,F
0653:  BTFSS  03.2
0654:  GOTO   661
0655:  INCF   79,F
0656:  BTFSS  03.2
0657:  GOTO   661
0658:  INCF   78,F
0659:  BTFSS  03.2
065A:  GOTO   661
065B:  RRF    78,F
065C:  RRF    79,F
065D:  RRF    7A,F
065E:  INCF   77,F
065F:  BTFSC  03.2
0660:  GOTO   66B
0661:  MOVF   2E,W
0662:  MOVWF  36
0663:  MOVF   32,W
0664:  XORWF  36,F
0665:  BTFSS  36.7
0666:  GOTO   669
0667:  BSF    78.7
0668:  GOTO   66F
0669:  BCF    78.7
066A:  GOTO   66F
066B:  CLRF   77
066C:  CLRF   78
066D:  CLRF   79
066E:  CLRF   7A
066F:  BCF    03.5
0670:  RETURN
0671:  BSF    03.5
0672:  MOVF   24,W
0673:  BTFSC  03.2
0674:  GOTO   737
0675:  MOVWF  30
0676:  MOVF   28,W
0677:  BTFSC  03.2
0678:  GOTO   737
0679:  SUBWF  30,F
067A:  BTFSS  03.0
067B:  GOTO   681
067C:  MOVLW  7F
067D:  ADDWF  30,F
067E:  BTFSC  03.0
067F:  GOTO   737
0680:  GOTO   687
0681:  MOVLW  81
0682:  SUBWF  30,F
0683:  BTFSS  03.0
0684:  GOTO   737
0685:  BTFSC  03.2
0686:  GOTO   737
0687:  MOVF   30,W
0688:  MOVWF  77
0689:  CLRF   78
068A:  CLRF   79
068B:  CLRF   7A
068C:  CLRF   2F
068D:  MOVF   25,W
068E:  MOVWF  2E
068F:  BSF    2E.7
0690:  MOVF   26,W
0691:  MOVWF  2D
0692:  MOVF   27,W
0693:  MOVWF  2C
0694:  MOVLW  19
0695:  MOVWF  30
0696:  MOVF   2B,W
0697:  SUBWF  2C,F
0698:  BTFSC  03.0
0699:  GOTO   6AA
069A:  MOVLW  01
069B:  SUBWF  2D,F
069C:  BTFSC  03.0
069D:  GOTO   6AA
069E:  SUBWF  2E,F
069F:  BTFSC  03.0
06A0:  GOTO   6AA
06A1:  SUBWF  2F,F
06A2:  BTFSC  03.0
06A3:  GOTO   6AA
06A4:  INCF   2F,F
06A5:  INCF   2E,F
06A6:  INCF   2D,F
06A7:  MOVF   2B,W
06A8:  ADDWF  2C,F
06A9:  GOTO   6DC
06AA:  MOVF   2A,W
06AB:  SUBWF  2D,F
06AC:  BTFSC  03.0
06AD:  GOTO   6C5
06AE:  MOVLW  01
06AF:  SUBWF  2E,F
06B0:  BTFSC  03.0
06B1:  GOTO   6C5
06B2:  SUBWF  2F,F
06B3:  BTFSC  03.0
06B4:  GOTO   6C5
06B5:  INCF   2F,F
06B6:  INCF   2E,F
06B7:  MOVF   2A,W
06B8:  ADDWF  2D,F
06B9:  MOVF   2B,W
06BA:  ADDWF  2C,F
06BB:  BTFSS  03.0
06BC:  GOTO   6DC
06BD:  INCF   2D,F
06BE:  BTFSS  03.2
06BF:  GOTO   6DC
06C0:  INCF   2E,F
06C1:  BTFSS  03.2
06C2:  GOTO   6DC
06C3:  INCF   2F,F
06C4:  GOTO   6DC
06C5:  MOVF   29,W
06C6:  IORLW  80
06C7:  SUBWF  2E,F
06C8:  BTFSC  03.0
06C9:  GOTO   6DB
06CA:  MOVLW  01
06CB:  SUBWF  2F,F
06CC:  BTFSC  03.0
06CD:  GOTO   6DB
06CE:  INCF   2F,F
06CF:  MOVF   29,W
06D0:  IORLW  80
06D1:  ADDWF  2E,F
06D2:  MOVF   2A,W
06D3:  ADDWF  2D,F
06D4:  BTFSS  03.0
06D5:  GOTO   6B9
06D6:  INCF   2E,F
06D7:  BTFSS  03.2
06D8:  GOTO   6B9
06D9:  INCF   2F,F
06DA:  GOTO   6B9
06DB:  BSF    7A.0
06DC:  DECFSZ 30,F
06DD:  GOTO   6DF
06DE:  GOTO   6EA
06DF:  BCF    03.0
06E0:  RLF    2C,F
06E1:  RLF    2D,F
06E2:  RLF    2E,F
06E3:  RLF    2F,F
06E4:  BCF    03.0
06E5:  RLF    7A,F
06E6:  RLF    79,F
06E7:  RLF    78,F
06E8:  RLF    31,F
06E9:  GOTO   696
06EA:  BTFSS  31.0
06EB:  GOTO   6F2
06EC:  BCF    03.0
06ED:  RRF    78,F
06EE:  RRF    79,F
06EF:  RRF    7A,F
06F0:  RRF    31,F
06F1:  GOTO   6F5
06F2:  DECF   77,F
06F3:  BTFSC  03.2
06F4:  GOTO   737
06F5:  BTFSC  31.7
06F6:  GOTO   71E
06F7:  BCF    03.0
06F8:  RLF    2C,F
06F9:  RLF    2D,F
06FA:  RLF    2E,F
06FB:  RLF    2F,F
06FC:  MOVF   2B,W
06FD:  SUBWF  2C,F
06FE:  BTFSC  03.0
06FF:  GOTO   70A
0700:  MOVLW  01
0701:  SUBWF  2D,F
0702:  BTFSC  03.0
0703:  GOTO   70A
0704:  SUBWF  2E,F
0705:  BTFSC  03.0
0706:  GOTO   70A
0707:  SUBWF  2F,F
0708:  BTFSS  03.0
0709:  GOTO   72D
070A:  MOVF   2A,W
070B:  SUBWF  2D,F
070C:  BTFSC  03.0
070D:  GOTO   715
070E:  MOVLW  01
070F:  SUBWF  2E,F
0710:  BTFSC  03.0
0711:  GOTO   715
0712:  SUBWF  2F,F
0713:  BTFSS  03.0
0714:  GOTO   72D
0715:  MOVF   29,W
0716:  IORLW  80
0717:  SUBWF  2E,F
0718:  BTFSC  03.0
0719:  GOTO   71E
071A:  MOVLW  01
071B:  SUBWF  2F,F
071C:  BTFSS  03.0
071D:  GOTO   72D
071E:  INCF   7A,F
071F:  BTFSS  03.2
0720:  GOTO   72D
0721:  INCF   79,F
0722:  BTFSS  03.2
0723:  GOTO   72D
0724:  INCF   78,F
0725:  BTFSS  03.2
0726:  GOTO   72D
0727:  INCF   77,F
0728:  BTFSC  03.2
0729:  GOTO   737
072A:  RRF    78,F
072B:  RRF    79,F
072C:  RRF    7A,F
072D:  MOVF   25,W
072E:  MOVWF  30
072F:  MOVF   29,W
0730:  XORWF  30,F
0731:  BTFSS  30.7
0732:  GOTO   735
0733:  BSF    78.7
0734:  GOTO   73B
0735:  BCF    78.7
0736:  GOTO   73B
0737:  CLRF   77
0738:  CLRF   78
0739:  CLRF   79
073A:  CLRF   7A
073B:  BCF    03.5
073C:  RETURN
073D:  BTFSC  03.1
073E:  GOTO   742
073F:  MOVLW  B5
0740:  MOVWF  04
0741:  BCF    03.7
0742:  CLRF   77
0743:  CLRF   78
0744:  CLRF   79
0745:  CLRF   7A
0746:  BSF    03.5
0747:  CLRF   35
0748:  CLRF   36
0749:  CLRF   37
074A:  CLRF   38
074B:  MOVF   34,W
074C:  IORWF  33,W
074D:  IORWF  32,W
074E:  IORWF  31,W
074F:  BTFSC  03.2
0750:  GOTO   781
0751:  MOVLW  20
0752:  MOVWF  39
0753:  BCF    03.0
0754:  RLF    2D,F
0755:  RLF    2E,F
0756:  RLF    2F,F
0757:  RLF    30,F
0758:  RLF    35,F
0759:  RLF    36,F
075A:  RLF    37,F
075B:  RLF    38,F
075C:  MOVF   34,W
075D:  SUBWF  38,W
075E:  BTFSS  03.2
075F:  GOTO   76A
0760:  MOVF   33,W
0761:  SUBWF  37,W
0762:  BTFSS  03.2
0763:  GOTO   76A
0764:  MOVF   32,W
0765:  SUBWF  36,W
0766:  BTFSS  03.2
0767:  GOTO   76A
0768:  MOVF   31,W
0769:  SUBWF  35,W
076A:  BTFSS  03.0
076B:  GOTO   77B
076C:  MOVF   31,W
076D:  SUBWF  35,F
076E:  MOVF   32,W
076F:  BTFSS  03.0
0770:  INCFSZ 32,W
0771:  SUBWF  36,F
0772:  MOVF   33,W
0773:  BTFSS  03.0
0774:  INCFSZ 33,W
0775:  SUBWF  37,F
0776:  MOVF   34,W
0777:  BTFSS  03.0
0778:  INCFSZ 34,W
0779:  SUBWF  38,F
077A:  BSF    03.0
077B:  RLF    77,F
077C:  RLF    78,F
077D:  RLF    79,F
077E:  RLF    7A,F
077F:  DECFSZ 39,F
0780:  GOTO   753
0781:  MOVF   35,W
0782:  MOVWF  00
0783:  INCF   04,F
0784:  MOVF   36,W
0785:  MOVWF  00
0786:  INCF   04,F
0787:  MOVF   37,W
0788:  MOVWF  00
0789:  INCF   04,F
078A:  MOVF   38,W
078B:  MOVWF  00
078C:  BCF    03.5
078D:  RETURN
078E:  MOVF   4C,W
078F:  MOVWF  04
0790:  BCF    03.7
0791:  BTFSC  4D.0
0792:  BSF    03.7
0793:  BSF    03.5
0794:  MOVF   2D,W
0795:  MOVWF  00
0796:  INCF   04,F
0797:  CLRF   00
0798:  BCF    03.5
0799:  INCF   4C,F
079A:  BTFSC  03.2
079B:  INCF   4D,F
079C:  RETURN
*
0800:  MOVLW  80
0801:  BTFSS  03.1
0802:  GOTO   006
0803:  BSF    03.5
0804:  XORWF  29,F
0805:  BCF    03.5
0806:  BSF    03.5
0807:  CLRF   2E
0808:  CLRF   2F
0809:  MOVF   25,W
080A:  MOVWF  2D
080B:  MOVF   29,W
080C:  XORWF  2D,F
080D:  MOVF   24,W
080E:  BTFSC  03.2
080F:  GOTO   0F4
0810:  MOVWF  2C
0811:  MOVWF  77
0812:  MOVF   28,W
0813:  BTFSC  03.2
0814:  GOTO   0FD
0815:  SUBWF  2C,F
0816:  BTFSC  03.2
0817:  GOTO   099
0818:  BTFSS  03.0
0819:  GOTO   057
081A:  MOVF   29,W
081B:  MOVWF  32
081C:  BSF    32.7
081D:  MOVF   2A,W
081E:  MOVWF  31
081F:  MOVF   2B,W
0820:  MOVWF  30
0821:  CLRF   2F
0822:  BCF    03.0
0823:  RRF    32,F
0824:  RRF    31,F
0825:  RRF    30,F
0826:  RRF    2F,F
0827:  DECFSZ 2C,F
0828:  GOTO   021
0829:  BTFSS  2D.7
082A:  GOTO   02E
082B:  BSF    2E.0
082C:  GOTO   111
082D:  BCF    2E.0
082E:  BCF    2C.0
082F:  BSF    2E.4
0830:  MOVLW  A7
0831:  MOVWF  04
0832:  BCF    03.7
0833:  GOTO   126
0834:  BCF    2E.4
0835:  BTFSC  2D.7
0836:  GOTO   041
0837:  BTFSS  2C.0
0838:  GOTO   04C
0839:  RRF    32,F
083A:  RRF    31,F
083B:  RRF    30,F
083C:  RRF    2F,F
083D:  INCF   77,F
083E:  BTFSC  03.2
083F:  GOTO   10C
0840:  GOTO   04C
0841:  BTFSC  32.7
0842:  GOTO   04F
0843:  BCF    03.0
0844:  RLF    2F,F
0845:  RLF    30,F
0846:  RLF    31,F
0847:  RLF    32,F
0848:  DECF   77,F
0849:  BTFSC  03.2
084A:  GOTO   10C
084B:  GOTO   041
084C:  BSF    2E.6
084D:  GOTO   0B9
084E:  BCF    2E.6
084F:  MOVF   25,W
0850:  MOVWF  2D
0851:  BTFSS  2D.7
0852:  GOTO   055
0853:  BSF    32.7
0854:  GOTO   105
0855:  BCF    32.7
0856:  GOTO   105
0857:  MOVF   28,W
0858:  MOVWF  2C
0859:  MOVWF  77
085A:  MOVF   24,W
085B:  SUBWF  2C,F
085C:  MOVF   25,W
085D:  MOVWF  32
085E:  BSF    32.7
085F:  MOVF   26,W
0860:  MOVWF  31
0861:  MOVF   27,W
0862:  MOVWF  30
0863:  CLRF   2F
0864:  BCF    03.0
0865:  RRF    32,F
0866:  RRF    31,F
0867:  RRF    30,F
0868:  RRF    2F,F
0869:  DECFSZ 2C,F
086A:  GOTO   063
086B:  BTFSS  2D.7
086C:  GOTO   070
086D:  BSF    2E.1
086E:  GOTO   111
086F:  BCF    2E.1
0870:  BCF    2C.0
0871:  BSF    2E.5
0872:  MOVLW  AB
0873:  MOVWF  04
0874:  BCF    03.7
0875:  GOTO   126
0876:  BCF    2E.5
0877:  BTFSC  2D.7
0878:  GOTO   083
0879:  BTFSS  2C.0
087A:  GOTO   08E
087B:  RRF    32,F
087C:  RRF    31,F
087D:  RRF    30,F
087E:  RRF    2F,F
087F:  INCF   77,F
0880:  BTFSC  03.2
0881:  GOTO   10C
0882:  GOTO   08E
0883:  BTFSC  32.7
0884:  GOTO   091
0885:  BCF    03.0
0886:  RLF    2F,F
0887:  RLF    30,F
0888:  RLF    31,F
0889:  RLF    32,F
088A:  DECF   77,F
088B:  BTFSC  03.2
088C:  GOTO   10C
088D:  GOTO   083
088E:  BSF    2E.7
088F:  GOTO   0B9
0890:  BCF    2E.7
0891:  MOVF   29,W
0892:  MOVWF  2D
0893:  BTFSS  2D.7
0894:  GOTO   097
0895:  BSF    32.7
0896:  GOTO   105
0897:  BCF    32.7
0898:  GOTO   105
0899:  MOVF   29,W
089A:  MOVWF  32
089B:  BSF    32.7
089C:  MOVF   2A,W
089D:  MOVWF  31
089E:  MOVF   2B,W
089F:  MOVWF  30
08A0:  BTFSS  2D.7
08A1:  GOTO   0A6
08A2:  BCF    32.7
08A3:  BSF    2E.2
08A4:  GOTO   111
08A5:  BCF    2E.2
08A6:  CLRF   2F
08A7:  BCF    2C.0
08A8:  MOVLW  A7
08A9:  MOVWF  04
08AA:  BCF    03.7
08AB:  GOTO   126
08AC:  BTFSC  2D.7
08AD:  GOTO   0CF
08AE:  MOVF   25,W
08AF:  MOVWF  2D
08B0:  BTFSS  2C.0
08B1:  GOTO   0B9
08B2:  RRF    32,F
08B3:  RRF    31,F
08B4:  RRF    30,F
08B5:  RRF    2F,F
08B6:  INCF   77,F
08B7:  BTFSC  03.2
08B8:  GOTO   10C
08B9:  BTFSS  2F.7
08BA:  GOTO   0CA
08BB:  INCF   30,F
08BC:  BTFSS  03.2
08BD:  GOTO   0CA
08BE:  INCF   31,F
08BF:  BTFSS  03.2
08C0:  GOTO   0CA
08C1:  INCF   32,F
08C2:  BTFSS  03.2
08C3:  GOTO   0CA
08C4:  RRF    32,F
08C5:  RRF    31,F
08C6:  RRF    30,F
08C7:  INCF   77,F
08C8:  BTFSC  03.2
08C9:  GOTO   10C
08CA:  BTFSC  2E.6
08CB:  GOTO   04E
08CC:  BTFSC  2E.7
08CD:  GOTO   090
08CE:  GOTO   0EE
08CF:  MOVLW  80
08D0:  XORWF  32,F
08D1:  BTFSS  32.7
08D2:  GOTO   0D7
08D3:  GOTO   111
08D4:  MOVF   29,W
08D5:  MOVWF  2D
08D6:  GOTO   0E4
08D7:  MOVF   25,W
08D8:  MOVWF  2D
08D9:  MOVF   32,F
08DA:  BTFSS  03.2
08DB:  GOTO   0E4
08DC:  MOVF   31,F
08DD:  BTFSS  03.2
08DE:  GOTO   0E4
08DF:  MOVF   30,F
08E0:  BTFSS  03.2
08E1:  GOTO   0E4
08E2:  CLRF   77
08E3:  GOTO   105
08E4:  BTFSC  32.7
08E5:  GOTO   0EE
08E6:  BCF    03.0
08E7:  RLF    2F,F
08E8:  RLF    30,F
08E9:  RLF    31,F
08EA:  RLF    32,F
08EB:  DECFSZ 77,F
08EC:  GOTO   0E4
08ED:  GOTO   10C
08EE:  BTFSS  2D.7
08EF:  GOTO   0F2
08F0:  BSF    32.7
08F1:  GOTO   105
08F2:  BCF    32.7
08F3:  GOTO   105
08F4:  MOVF   28,W
08F5:  MOVWF  77
08F6:  MOVF   29,W
08F7:  MOVWF  32
08F8:  MOVF   2A,W
08F9:  MOVWF  31
08FA:  MOVF   2B,W
08FB:  MOVWF  30
08FC:  GOTO   105
08FD:  MOVF   24,W
08FE:  MOVWF  77
08FF:  MOVF   25,W
0900:  MOVWF  32
0901:  MOVF   26,W
0902:  MOVWF  31
0903:  MOVF   27,W
0904:  MOVWF  30
0905:  MOVF   32,W
0906:  MOVWF  78
0907:  MOVF   31,W
0908:  MOVWF  79
0909:  MOVF   30,W
090A:  MOVWF  7A
090B:  GOTO   144
090C:  CLRF   77
090D:  CLRF   78
090E:  CLRF   79
090F:  CLRF   7A
0910:  GOTO   144
0911:  CLRF   2F
0912:  COMF   30,F
0913:  COMF   31,F
0914:  COMF   32,F
0915:  COMF   2F,F
0916:  INCF   2F,F
0917:  BTFSS  03.2
0918:  GOTO   11F
0919:  INCF   30,F
091A:  BTFSS  03.2
091B:  GOTO   11F
091C:  INCF   31,F
091D:  BTFSC  03.2
091E:  INCF   32,F
091F:  BTFSC  2E.0
0920:  GOTO   02D
0921:  BTFSC  2E.1
0922:  GOTO   06F
0923:  BTFSC  2E.2
0924:  GOTO   0A5
0925:  GOTO   0D4
0926:  MOVF   00,W
0927:  ADDWF  30,F
0928:  BTFSS  03.0
0929:  GOTO   130
092A:  INCF   31,F
092B:  BTFSS  03.2
092C:  GOTO   130
092D:  INCF   32,F
092E:  BTFSC  03.2
092F:  BSF    2C.0
0930:  DECF   04,F
0931:  MOVF   00,W
0932:  ADDWF  31,F
0933:  BTFSS  03.0
0934:  GOTO   138
0935:  INCF   32,F
0936:  BTFSC  03.2
0937:  BSF    2C.0
0938:  DECF   04,F
0939:  MOVF   00,W
093A:  BTFSS  00.7
093B:  XORLW  80
093C:  ADDWF  32,F
093D:  BTFSC  03.0
093E:  BSF    2C.0
093F:  BTFSC  2E.4
0940:  GOTO   034
0941:  BTFSC  2E.5
0942:  GOTO   076
0943:  GOTO   0AC
0944:  BCF    03.5
0945:  RETURN
0946:  MOVF   04,W
0947:  BSF    03.5
0948:  MOVWF  25
0949:  MOVF   24,W
094A:  MOVWF  27
094B:  BTFSC  03.2
094C:  GOTO   16A
094D:  MOVF   23,W
094E:  MOVWF  30
094F:  MOVF   22,W
0950:  MOVWF  2F
0951:  MOVF   21,W
0952:  MOVWF  2E
0953:  MOVF   20,W
0954:  MOVWF  2D
0955:  CLRF   34
0956:  CLRF   33
0957:  MOVLW  20
0958:  MOVWF  32
0959:  MOVLW  82
095A:  MOVWF  31
095B:  BCF    0A.3
095C:  BCF    03.5
095D:  CALL   5FA
095E:  BSF    0A.3
095F:  MOVF   7A,W
0960:  BSF    03.5
0961:  MOVWF  23
0962:  MOVF   79,W
0963:  MOVWF  22
0964:  MOVF   78,W
0965:  MOVWF  21
0966:  MOVF   77,W
0967:  MOVWF  20
0968:  DECFSZ 27,F
0969:  GOTO   14D
096A:  MOVF   23,W
096B:  MOVWF  30
096C:  MOVF   22,W
096D:  MOVWF  2F
096E:  MOVF   21,W
096F:  MOVWF  2E
0970:  MOVF   20,W
0971:  MOVWF  2D
0972:  MOVF   2D,W
0973:  SUBLW  B6
0974:  MOVWF  2D
0975:  CLRF   7A
0976:  MOVF   2E,W
0977:  MOVWF  31
0978:  BSF    2E.7
0979:  BCF    03.0
097A:  RRF    2E,F
097B:  RRF    2F,F
097C:  RRF    30,F
097D:  RRF    7A,F
097E:  RRF    79,F
097F:  RRF    78,F
0980:  RRF    77,F
0981:  DECFSZ 2D,F
0982:  GOTO   179
0983:  BTFSS  31.7
0984:  GOTO   190
0985:  COMF   77,F
0986:  COMF   78,F
0987:  COMF   79,F
0988:  COMF   7A,F
0989:  INCF   77,F
098A:  BTFSC  03.2
098B:  INCF   78,F
098C:  BTFSC  03.2
098D:  INCF   79,F
098E:  BTFSC  03.2
098F:  INCF   7A,F
0990:  MOVF   7A,W
0991:  MOVWF  23
0992:  MOVF   79,W
0993:  MOVWF  22
0994:  MOVF   78,W
0995:  MOVWF  21
0996:  MOVF   77,W
0997:  MOVWF  20
0998:  BTFSS  23.7
0999:  GOTO   1A7
099A:  DECF   25,F
099B:  BSF    25.5
099C:  COMF   20,F
099D:  COMF   21,F
099E:  COMF   22,F
099F:  COMF   23,F
09A0:  INCF   20,F
09A1:  BTFSC  03.2
09A2:  INCF   21,F
09A3:  BTFSC  03.2
09A4:  INCF   22,F
09A5:  BTFSC  03.2
09A6:  INCF   23,F
09A7:  MOVLW  3B
09A8:  MOVWF  2C
09A9:  MOVLW  9A
09AA:  MOVWF  2B
09AB:  MOVLW  CA
09AC:  MOVWF  2A
09AD:  CLRF   29
09AE:  MOVLW  0A
09AF:  MOVWF  27
09B0:  MOVF   24,W
09B1:  BTFSC  03.2
09B2:  INCF   25,F
09B3:  BSF    03.1
09B4:  MOVLW  A0
09B5:  MOVWF  04
09B6:  BCF    03.7
09B7:  MOVF   23,W
09B8:  MOVWF  30
09B9:  MOVF   22,W
09BA:  MOVWF  2F
09BB:  MOVF   21,W
09BC:  MOVWF  2E
09BD:  MOVF   20,W
09BE:  MOVWF  2D
09BF:  MOVF   2C,W
09C0:  MOVWF  34
09C1:  MOVF   2B,W
09C2:  MOVWF  33
09C3:  MOVF   2A,W
09C4:  MOVWF  32
09C5:  MOVF   29,W
09C6:  MOVWF  31
09C7:  BCF    0A.3
09C8:  BCF    03.5
09C9:  CALL   73D
09CA:  BSF    0A.3
09CB:  MOVF   78,W
09CC:  MOVF   77,F
09CD:  BTFSS  03.2
09CE:  GOTO   1E6
09CF:  BSF    03.5
09D0:  INCF   24,W
09D1:  SUBWF  27,W
09D2:  BTFSS  03.2
09D3:  GOTO   1D6
09D4:  BCF    03.5
09D5:  GOTO   1E6
09D6:  MOVF   25,W
09D7:  BTFSC  03.2
09D8:  GOTO   1E9
09D9:  ANDLW  0F
09DA:  SUBWF  27,W
09DB:  BTFSC  03.2
09DC:  GOTO   1DF
09DD:  BTFSC  03.0
09DE:  GOTO   229
09DF:  BTFSC  25.7
09E0:  GOTO   229
09E1:  BTFSC  25.6
09E2:  GOTO   1E9
09E3:  MOVLW  20
09E4:  GOTO   221
09E5:  BCF    03.5
09E6:  MOVLW  20
09E7:  BSF    03.5
09E8:  ANDWF  25,F
09E9:  BTFSS  25.5
09EA:  GOTO   1FB
09EB:  BCF    25.5
09EC:  MOVF   24,W
09ED:  BTFSS  03.2
09EE:  DECF   25,F
09EF:  MOVF   77,W
09F0:  MOVWF  25
09F1:  MOVLW  2D
09F2:  MOVWF  2D
09F3:  BCF    0A.3
09F4:  BCF    03.5
09F5:  CALL   78E
09F6:  BSF    0A.3
09F7:  BSF    03.5
09F8:  MOVF   25,W
09F9:  MOVWF  77
09FA:  CLRF   25
09FB:  MOVF   24,W
09FC:  SUBWF  27,W
09FD:  BTFSS  03.2
09FE:  GOTO   20D
09FF:  MOVF   77,W
0A00:  MOVWF  25
0A01:  MOVLW  2E
0A02:  MOVWF  2D
0A03:  BCF    0A.3
0A04:  BCF    03.5
0A05:  CALL   78E
0A06:  BSF    0A.3
0A07:  BSF    03.5
0A08:  MOVF   25,W
0A09:  MOVWF  77
0A0A:  MOVLW  20
0A0B:  ANDWF  25,F
0A0C:  MOVLW  00
0A0D:  MOVLW  30
0A0E:  BTFSS  25.5
0A0F:  GOTO   221
0A10:  BCF    25.5
0A11:  MOVF   24,W
0A12:  BTFSS  03.2
0A13:  DECF   25,F
0A14:  MOVF   77,W
0A15:  MOVWF  25
0A16:  MOVLW  2D
0A17:  MOVWF  2D
0A18:  BCF    0A.3
0A19:  BCF    03.5
0A1A:  CALL   78E
0A1B:  BSF    0A.3
0A1C:  BSF    03.5
0A1D:  MOVF   25,W
0A1E:  MOVWF  77
0A1F:  CLRF   25
0A20:  MOVLW  30
0A21:  ADDWF  77,F
0A22:  MOVF   77,W
0A23:  MOVWF  2D
0A24:  BCF    0A.3
0A25:  BCF    03.5
0A26:  CALL   78E
0A27:  BSF    0A.3
0A28:  BSF    03.5
0A29:  BCF    03.1
0A2A:  MOVF   2C,W
0A2B:  MOVWF  30
0A2C:  MOVF   2B,W
0A2D:  MOVWF  2F
0A2E:  MOVF   2A,W
0A2F:  MOVWF  2E
0A30:  MOVF   29,W
0A31:  MOVWF  2D
0A32:  CLRF   34
0A33:  CLRF   33
0A34:  CLRF   32
0A35:  MOVLW  0A
0A36:  MOVWF  31
0A37:  BCF    0A.3
0A38:  BCF    03.5
0A39:  CALL   73D
0A3A:  BSF    0A.3
0A3B:  MOVF   7A,W
0A3C:  BSF    03.5
0A3D:  MOVWF  2C
0A3E:  MOVF   79,W
0A3F:  MOVWF  2B
0A40:  MOVF   78,W
0A41:  MOVWF  2A
0A42:  MOVF   77,W
0A43:  MOVWF  29
0A44:  DECFSZ 27,F
0A45:  GOTO   1B3
0A46:  BCF    03.5
0A47:  BSF    0A.3
0A48:  BCF    0A.4
0A49:  GOTO   3B6 (RETURN)
0A4A:  MOVLW  8E
0A4B:  MOVWF  77
0A4C:  BSF    03.5
0A4D:  MOVF   20,W
0A4E:  SUBWF  77,F
0A4F:  MOVF   21,W
0A50:  MOVWF  79
0A51:  MOVF   22,W
0A52:  MOVWF  78
0A53:  BSF    79.7
0A54:  MOVF   77,F
0A55:  BTFSC  03.2
0A56:  GOTO   262
0A57:  BCF    03.0
0A58:  MOVF   79,F
0A59:  BTFSS  03.2
0A5A:  GOTO   25E
0A5B:  MOVF   78,F
0A5C:  BTFSC  03.2
0A5D:  GOTO   262
0A5E:  RRF    79,F
0A5F:  RRF    78,F
0A60:  DECFSZ 77,F
0A61:  GOTO   257
0A62:  BTFSS  21.7
0A63:  GOTO   269
0A64:  COMF   78,F
0A65:  COMF   79,F
0A66:  INCF   78,F
0A67:  BTFSC  03.2
0A68:  INCF   79,F
0A69:  BCF    03.5
0A6A:  RETURN
....................  
.................... #list 
....................  
.................... #Device ADC=10; 
.................... #use delay(clock = 4000000) 
*
02F1:  MOVLW  A0
02F2:  MOVWF  04
02F3:  BCF    03.7
02F4:  MOVF   00,W
02F5:  BTFSC  03.2
02F6:  GOTO   305
02F7:  MOVLW  01
02F8:  MOVWF  78
02F9:  CLRF   77
02FA:  DECFSZ 77,F
02FB:  GOTO   2FA
02FC:  DECFSZ 78,F
02FD:  GOTO   2F9
02FE:  MOVLW  4A
02FF:  MOVWF  77
0300:  DECFSZ 77,F
0301:  GOTO   300
0302:  GOTO   303
0303:  DECFSZ 00,F
0304:  GOTO   2F7
0305:  BSF    0A.3
0306:  BCF    0A.4
0307:  GOTO   2CD (RETURN)
.................... #include<HDM64GS12.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           HDM64GS12.c                           //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// a KS0108 display controller. The HDM64GS12 is 128 by 64 pixels. //// 
.................... //// The driver treats the upper left pixel as (0,0).                //// 
.................... ////                                                                 //// 
.................... //// Use #define FAST_GLCD if the target chip has at least 1k of RAM //// 
.................... //// to decrease the time it takes to update the display.            //// 
.................... //// glcd_update() must then be called to update the display after   //// 
.................... //// changing the pixel information.                                 //// 
.................... //// See ex_glcd.c for suggested usage.                              //// 
.................... //// See KS0108.c for controlling a single 64 by 64 display          //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0  - LCD operating voltage (Constrast adjustment)        //// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_update()                                                  //// 
.................... ////     * Write the display data stored in RAM to the LCD           //// 
.................... ////     * Only available if FAST_GLCD is defined                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef HDM64GS12 
.................... #define HDM64GS12 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH   128 
.................... #endif 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1     PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2     PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI      PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW      PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E       PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST     PIN_C0   // Reset 
.................... #endif 
....................  
.................... #define GLCD_LEFT    0 
.................... #define GLCD_RIGHT   1 
....................  
.................... #ifndef ON 
.................... #define ON           1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF          0 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Function Prototypes 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void glcd_init(int1 mode); 
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color); 
.................... void glcd_fillScreen(int1 color); 
.................... void glcd_writeByte(int1 side, BYTE data); 
.................... BYTE glcd_readByte(int1 side); 
.................... void glcd_update(); 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifdef FAST_GLCD 
.................... struct 
.................... { 
....................    unsigned int8 left[512]; 
....................    unsigned int8 right[512]; 
.................... } displayData; 
.................... #endif 
....................  
....................  
.................... // Purpose:       Initialize the LCD. 
.................... //                Call before using any other LCD function. 
.................... // Inputs:        OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
023C:  BCF    20.0
023D:  MOVF   20,W
023E:  BSF    03.5
023F:  MOVWF  07
0240:  BCF    03.5
0241:  BSF    07.0
....................    output_low(GLCD_E); 
0242:  BSF    03.5
0243:  BCF    06.5
0244:  BCF    03.5
0245:  BCF    06.5
....................    output_low(GLCD_CS1); 
0246:  BSF    03.5
0247:  BCF    06.0
0248:  BCF    03.5
0249:  BCF    06.0
....................    output_low(GLCD_CS2); 
024A:  BSF    03.5
024B:  BCF    06.1
024C:  BCF    03.5
024D:  BCF    06.1
....................  
....................    output_low(GLCD_DI);                 // Set for instruction 
024E:  BSF    03.5
024F:  BCF    06.2
0250:  BCF    03.5
0251:  BCF    06.2
....................    glcd_writeByte(GLCD_LEFT,  0xC0);    // Specify first RAM line at the top 
0252:  BSF    03.5
0253:  CLRF   43
0254:  MOVLW  C0
0255:  MOVWF  44
0256:  BCF    03.5
0257:  CALL   1EA
....................    glcd_writeByte(GLCD_RIGHT, 0xC0);    //   of the screen 
0258:  MOVLW  01
0259:  BSF    03.5
025A:  MOVWF  43
025B:  MOVLW  C0
025C:  MOVWF  44
025D:  BCF    03.5
025E:  CALL   1EA
....................    glcd_writeByte(GLCD_LEFT,  0x40);    // Set the column address to 0 
025F:  BSF    03.5
0260:  CLRF   43
0261:  MOVLW  40
0262:  MOVWF  44
0263:  BCF    03.5
0264:  CALL   1EA
....................    glcd_writeByte(GLCD_RIGHT, 0x40); 
0265:  MOVLW  01
0266:  BSF    03.5
0267:  MOVWF  43
0268:  MOVLW  40
0269:  MOVWF  44
026A:  BCF    03.5
026B:  CALL   1EA
....................    glcd_writeByte(GLCD_LEFT,  0xB8);    // Set the page address to 0 
026C:  BSF    03.5
026D:  CLRF   43
026E:  MOVLW  B8
026F:  MOVWF  44
0270:  BCF    03.5
0271:  CALL   1EA
....................    glcd_writeByte(GLCD_RIGHT, 0xB8); 
0272:  MOVLW  01
0273:  BSF    03.5
0274:  MOVWF  43
0275:  MOVLW  B8
0276:  MOVWF  44
0277:  BCF    03.5
0278:  CALL   1EA
....................  
....................    if(mode == ON) 
0279:  BSF    03.5
027A:  DECFSZ 20,W
027B:  GOTO   28A
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3F); // Turn the display on 
027C:  CLRF   43
027D:  MOVLW  3F
027E:  MOVWF  44
027F:  BCF    03.5
0280:  CALL   1EA
....................       glcd_writeByte(GLCD_RIGHT, 0x3F); 
0281:  MOVLW  01
0282:  BSF    03.5
0283:  MOVWF  43
0284:  MOVLW  3F
0285:  MOVWF  44
0286:  BCF    03.5
0287:  CALL   1EA
....................    } 
0288:  GOTO   296
0289:  BSF    03.5
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3E); // Turn the display off 
028A:  CLRF   43
028B:  MOVLW  3E
028C:  MOVWF  44
028D:  BCF    03.5
028E:  CALL   1EA
....................       glcd_writeByte(GLCD_RIGHT, 0x3E); 
028F:  MOVLW  01
0290:  BSF    03.5
0291:  MOVWF  43
0292:  MOVLW  3E
0293:  MOVWF  44
0294:  BCF    03.5
0295:  CALL   1EA
....................    } 
....................  
....................    glcd_fillScreen(OFF);                // Clear the display 
0296:  BSF    03.5
0297:  CLRF   21
....................  
....................    #ifdef FAST_GLCD 
*
02ED:  BCF    03.5
02EE:  BSF    0A.3
02EF:  BCF    0A.4
02F0:  GOTO   2C6 (RETURN)
....................    glcd_update(); 
....................    #endif 
.................... } 
....................  
....................  
.................... // Purpose:    Update the LCD with data from the display arrays 
.................... #ifdef FAST_GLCD 
.................... void glcd_update() 
.................... { 
....................    unsigned int8 i, j; 
....................    unsigned int8 *p1, *p2; 
....................  
....................    p1 = displayData.left; 
....................    p2 = displayData.right; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
....................       glcd_writeByte(GLCD_LEFT, 0x40);          // Set horizontal address to 0 
....................       glcd_writeByte(GLCD_RIGHT, 0x40); 
....................       glcd_writeByte(GLCD_LEFT, i | 0xB8);      // Set page address 
....................       glcd_writeByte(GLCD_RIGHT, i | 0xB8); 
....................       output_high(GLCD_DI);                     // Set for data 
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
....................       { 
....................          glcd_writeByte(GLCD_LEFT, *p1++);      // Turn pixels on or off 
....................          glcd_writeByte(GLCD_RIGHT, *p2++);     // Turn pixels on or off 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Turn a pixel on a graphic LCD on or off 
.................... // Inputs:     1) x - the x coordinate of the pixel 
.................... //             2) y - the y coordinate of the pixel 
.................... //             3) color - ON or OFF 
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color) 
.................... #ifdef FAST_GLCD 
*
0337:  BSF    03.5
0338:  BCF    40.0
.................... { 
....................    unsigned int8* p; 
....................    unsigned int16 temp; 
....................    temp =  y/8; 
....................    temp *= 64; 
....................    temp += x; 
....................  
....................    if(x > 63) 
....................    { 
....................       p = displayData.right + temp - 64; 
....................    } 
....................    else 
....................    { 
....................       p = displayData.left + temp; 
....................    } 
....................  
....................    if(color) 
....................    { 
....................       bit_set(*p, y%8); 
....................    } 
....................    else 
....................    { 
....................       bit_clear(*p, y%8); 
....................    } 
.................... } 
.................... #else 
.................... { 
....................    BYTE data; 
....................    int1 side = GLCD_LEFT;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)              // Check for first or second display area 
0339:  MOVF   3C,W
033A:  SUBLW  3F
033B:  BTFSC  03.0
033C:  GOTO   340
....................    { 
....................       x -= 64; 
033D:  MOVLW  40
033E:  SUBWF  3C,F
....................       side = GLCD_RIGHT; 
033F:  BSF    40.0
....................    } 
....................  
....................    output_low(GLCD_DI);                         // Set for instruction 
0340:  BCF    06.2
0341:  BCF    03.5
0342:  BCF    06.2
....................    bit_clear(x,7);                              // Clear the MSB. Part of an instruction code 
0343:  BSF    03.5
0344:  BCF    3C.7
....................    bit_set(x,6);                                // Set bit 6. Also part of an instruction code 
0345:  BSF    3C.6
....................    glcd_writeByte(side, x);                     // Set the horizontal address 
0346:  MOVLW  00
0347:  BTFSC  40.0
0348:  MOVLW  01
0349:  MOVWF  41
034A:  MOVWF  43
034B:  MOVF   3C,W
034C:  MOVWF  44
034D:  BCF    03.5
034E:  CALL   1EA
....................    glcd_writeByte(side, (y/8 & 0xBF) | 0xB8);   // Set the vertical page address 
034F:  MOVLW  00
0350:  BSF    03.5
0351:  BTFSC  40.0
0352:  MOVLW  01
0353:  MOVWF  41
0354:  RRF    3D,W
0355:  MOVWF  77
0356:  RRF    77,F
0357:  RRF    77,F
0358:  MOVLW  1F
0359:  ANDWF  77,F
035A:  MOVF   77,W
035B:  ANDLW  BF
035C:  IORLW  B8
035D:  MOVWF  42
035E:  MOVF   41,W
035F:  MOVWF  43
0360:  MOVF   42,W
0361:  MOVWF  44
0362:  BCF    03.5
0363:  CALL   1EA
....................    output_high(GLCD_DI);                        // Set for data 
0364:  BSF    03.5
0365:  BCF    06.2
0366:  BCF    03.5
0367:  BSF    06.2
....................    glcd_readByte(side);                         // Need two reads to get data 
0368:  MOVLW  00
0369:  BSF    03.5
036A:  BTFSC  40.0
036B:  MOVLW  01
036C:  MOVWF  41
036D:  MOVWF  42
036E:  BCF    03.5
036F:  CALL   308
....................    data = glcd_readByte(side);                  //  at new address 
0370:  MOVLW  00
0371:  BSF    03.5
0372:  BTFSC  40.0
0373:  MOVLW  01
0374:  MOVWF  41
0375:  MOVWF  42
0376:  BCF    03.5
0377:  CALL   308
0378:  MOVF   78,W
0379:  BSF    03.5
037A:  MOVWF  3F
....................  
....................    if(color == ON) 
037B:  DECFSZ 3E,W
037C:  GOTO   38D
....................       bit_set(data, y%8);        // Turn the pixel on 
037D:  MOVF   3D,W
037E:  ANDLW  07
037F:  MOVWF  41
0380:  MOVLW  01
0381:  MOVWF  77
0382:  MOVF   41,W
0383:  MOVWF  78
0384:  BTFSC  03.2
0385:  GOTO   38A
0386:  BCF    03.0
0387:  RLF    77,F
0388:  DECFSZ 78,F
0389:  GOTO   386
038A:  MOVF   77,W
038B:  IORWF  3F,F
038C:  GOTO   39D
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
038D:  MOVF   3D,W
038E:  ANDLW  07
038F:  MOVWF  41
0390:  MOVLW  01
0391:  MOVWF  77
0392:  MOVF   41,W
0393:  MOVWF  78
0394:  BTFSC  03.2
0395:  GOTO   39A
0396:  BCF    03.0
0397:  RLF    77,F
0398:  DECFSZ 78,F
0399:  GOTO   396
039A:  MOVF   77,W
039B:  XORLW  FF
039C:  ANDWF  3F,F
....................  
....................    output_low(GLCD_DI);          // Set for instruction 
039D:  BCF    06.2
039E:  BCF    03.5
039F:  BCF    06.2
....................    glcd_writeByte(side, x);      // Set the horizontal address 
03A0:  MOVLW  00
03A1:  BSF    03.5
03A2:  BTFSC  40.0
03A3:  MOVLW  01
03A4:  MOVWF  41
03A5:  MOVWF  43
03A6:  MOVF   3C,W
03A7:  MOVWF  44
03A8:  BCF    03.5
03A9:  CALL   1EA
....................    output_high(GLCD_DI);         // Set for data 
03AA:  BSF    03.5
03AB:  BCF    06.2
03AC:  BCF    03.5
03AD:  BSF    06.2
....................    glcd_writeByte(side, data);   // Write the pixel data 
03AE:  MOVLW  00
03AF:  BSF    03.5
03B0:  BTFSC  40.0
03B1:  MOVLW  01
03B2:  MOVWF  41
03B3:  MOVWF  43
03B4:  MOVF   3F,W
03B5:  MOVWF  44
03B6:  BCF    03.5
03B7:  CALL   1EA
03B8:  RETURN
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Fill the LCD screen with the passed in color 
.................... // Inputs:     ON  - turn all the pixels on 
.................... //             OFF - turn all the pixels off 
.................... void glcd_fillScreen(int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    unsigned int8  data; 
....................    unsigned int8  *p1, *p2; 
....................    unsigned int16 i; 
....................  
....................    p1 = displayData.left; 
....................    p2 = displayData.right; 
....................    data = 0xFF * color; 
....................  
....................    for(i=0; i<512; ++i) 
....................    { 
....................    	*p1++ = data; 
....................    	*p2++ = data; 
....................    } 
.................... } 
.................... #else 
.................... { 
....................    unsigned int8 i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
0298:  CLRF   22
0299:  MOVF   22,W
029A:  SUBLW  07
029B:  BTFSS  03.0
029C:  GOTO   2ED
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
029D:  BCF    06.2
029E:  BCF    03.5
029F:  BCF    06.2
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0 
02A0:  BSF    03.5
02A1:  CLRF   43
02A2:  MOVLW  40
02A3:  MOVWF  44
02A4:  BCF    03.5
02A5:  CALL   1EA
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000); 
02A6:  MOVLW  01
02A7:  BSF    03.5
02A8:  MOVWF  43
02A9:  MOVLW  40
02AA:  MOVWF  44
02AB:  BCF    03.5
02AC:  CALL   1EA
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address 
02AD:  BSF    03.5
02AE:  MOVF   22,W
02AF:  IORLW  B8
02B0:  MOVWF  24
02B1:  CLRF   43
02B2:  MOVF   24,W
02B3:  MOVWF  44
02B4:  BCF    03.5
02B5:  CALL   1EA
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000); 
02B6:  BSF    03.5
02B7:  MOVF   22,W
02B8:  IORLW  B8
02B9:  MOVWF  24
02BA:  MOVLW  01
02BB:  MOVWF  43
02BC:  MOVF   24,W
02BD:  MOVWF  44
02BE:  BCF    03.5
02BF:  CALL   1EA
....................       output_high(GLCD_DI);                     // Set for data 
02C0:  BSF    03.5
02C1:  BCF    06.2
02C2:  BCF    03.5
02C3:  BSF    06.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
02C4:  BSF    03.5
02C5:  CLRF   23
02C6:  MOVF   23,W
02C7:  SUBLW  3F
02C8:  BTFSS  03.0
02C9:  GOTO   2EB
....................       { 
....................          glcd_writeByte(GLCD_LEFT, 0xFF*color);  // Turn pixels on or off 
02CA:  MOVLW  FF
02CB:  MOVWF  31
02CC:  MOVF   21,W
02CD:  MOVWF  32
02CE:  BCF    03.5
02CF:  CALL   215
02D0:  MOVF   78,W
02D1:  BSF    03.5
02D2:  MOVWF  24
02D3:  CLRF   43
02D4:  MOVF   24,W
02D5:  MOVWF  44
02D6:  BCF    03.5
02D7:  CALL   1EA
....................          glcd_writeByte(GLCD_RIGHT, 0xFF*color); // Turn pixels on or off 
02D8:  MOVLW  FF
02D9:  BSF    03.5
02DA:  MOVWF  31
02DB:  MOVF   21,W
02DC:  MOVWF  32
02DD:  BCF    03.5
02DE:  CALL   215
02DF:  MOVF   78,W
02E0:  BSF    03.5
02E1:  MOVWF  24
02E2:  MOVLW  01
02E3:  MOVWF  43
02E4:  MOVF   24,W
02E5:  MOVWF  44
02E6:  BCF    03.5
02E7:  CALL   1EA
02E8:  BSF    03.5
02E9:  INCF   23,F
02EA:  GOTO   2C6
....................       } 
02EB:  INCF   22,F
02EC:  GOTO   299
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Write a byte of data to the specified chip 
.................... // Inputs:     1) chipSelect - which chip to write the data to 
.................... //             2) data - the byte of data to write 
.................... void glcd_writeByte(int1 side, BYTE data) 
.................... { 
....................    set_tris_d(0x00); 
*
01EA:  MOVLW  00
01EB:  BSF    03.5
01EC:  MOVWF  08
....................     
....................    output_low(GLCD_RW);       // Set for writing 
01ED:  BCF    06.4
01EE:  BCF    03.5
01EF:  BCF    06.4
....................  
.................... 	 if(side)                   // Choose which side to write to 
01F0:  BSF    03.5
01F1:  MOVF   43,F
01F2:  BTFSC  03.2
01F3:  GOTO   1F9
....................       output_high(GLCD_CS2); 
01F4:  BCF    06.1
01F5:  BCF    03.5
01F6:  BSF    06.1
01F7:  GOTO   1FC
01F8:  BSF    03.5
....................    else 
....................       output_high(GLCD_CS1); 
01F9:  BCF    06.0
01FA:  BCF    03.5
01FB:  BSF    06.0
....................  
.................... 	 delay_us(1); 
01FC:  NOP
....................  
....................    output_d(data);            // Put the data on the port 
01FD:  BSF    03.5
01FE:  CLRF   08
01FF:  MOVF   44,W
0200:  BCF    03.5
0201:  MOVWF  08
....................    delay_us(1); 
0202:  NOP
....................    output_high(GLCD_E);       // Pulse the enable pin 
0203:  BSF    03.5
0204:  BCF    06.5
0205:  BCF    03.5
0206:  BSF    06.5
....................    delay_us(1); 
0207:  NOP
....................    output_low(GLCD_E); 
0208:  BSF    03.5
0209:  BCF    06.5
020A:  BCF    03.5
020B:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
020C:  BSF    03.5
020D:  BCF    06.0
020E:  BCF    03.5
020F:  BCF    06.0
....................    output_low(GLCD_CS2); 
0210:  BSF    03.5
0211:  BCF    06.1
0212:  BCF    03.5
0213:  BCF    06.1
0214:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:    Reads a byte of data from the specified chip 
.................... // Ouputs:     A byte of data read from the chip 
.................... BYTE glcd_readByte(int1 side) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................  
....................    set_tris_d(0xFF);          // Set port d to input 
*
0308:  MOVLW  FF
0309:  BSF    03.5
030A:  MOVWF  08
....................    output_high(GLCD_RW);      // Set for reading 
030B:  BCF    06.4
030C:  BCF    03.5
030D:  BSF    06.4
....................  
....................    if(side)                   // Choose which side to write to 
030E:  BSF    03.5
030F:  MOVF   42,F
0310:  BTFSC  03.2
0311:  GOTO   317
....................       output_high(GLCD_CS2); 
0312:  BCF    06.1
0313:  BCF    03.5
0314:  BSF    06.1
0315:  GOTO   31A
0316:  BSF    03.5
....................    else 
....................       output_high(GLCD_CS1); 
0317:  BCF    06.0
0318:  BCF    03.5
0319:  BSF    06.0
....................  
....................    delay_us(1); 
031A:  NOP
....................    output_high(GLCD_E);       // Pulse the enable pin 
031B:  BSF    03.5
031C:  BCF    06.5
031D:  BCF    03.5
031E:  BSF    06.5
....................    delay_us(1); 
031F:  NOP
....................    data = input_d();          // Get the data from the display's output register 
0320:  MOVLW  FF
0321:  BSF    03.5
0322:  MOVWF  08
0323:  BCF    03.5
0324:  MOVF   08,W
0325:  BSF    03.5
0326:  MOVWF  43
....................    output_low(GLCD_E); 
0327:  BCF    06.5
0328:  BCF    03.5
0329:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
032A:  BSF    03.5
032B:  BCF    06.0
032C:  BCF    03.5
032D:  BCF    06.0
....................    output_low(GLCD_CS2); 
032E:  BSF    03.5
032F:  BCF    06.1
0330:  BCF    03.5
0331:  BCF    06.1
....................    return data;               // Return the read data 
0332:  BSF    03.5
0333:  MOVF   43,W
0334:  MOVWF  78
0335:  BCF    03.5
0336:  RETURN
.................... } 
....................  
.................... #endif 
....................  
.................... #include<graphics.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          graphics.c                             //// 
.................... ////                                                                 //// 
.................... ////   This file contains functions to draw lines, rectangles, bars, //// 
.................... ////   circles and text to a display. A function which draws a       //// 
.................... ////   single pixel must be defined before calling the functions in  //// 
.................... ////   this file. Call it glcd_pixel(x, y, color) where x is the     //// 
.................... ////   horizontal coordinate, y is the vertical coordinate, and      //// 
.................... ////   color is 1 bit to turn the pixel on or off.                   //// 
.................... ////                                                                 //// 
.................... ////   * Note: (0, 0) is treated as the upper left corner            //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1, y1, x2, y2, color)                               //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color                                      //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1, y1, x2, y2, fill, color)                         //// 
.................... ////     * Draws a rectangle with one corner at point (x1,y1) and    //// 
.................... ////       the other corner at point (x2,y2)                         //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1, y1, x2, y2, width, color)                         //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point                                              //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x, y, radius, fill, color)                         //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x, y, textptr, size, color)                        //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y) //// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall            //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - This function wraps characters to the next line    //// 
.................... ////              use #define GLCD_WIDTH to specify a display width  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2010 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef GRAPHICS_DRAWING_FUNCTIONS 
.................... #define GRAPHICS_DRAWING_FUNCTIONS 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef ON 
.................... #define ON  1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF 0 
.................... #endif 
....................  
.................... #ifndef YES 
.................... #define YES 1 
.................... #endif 
....................  
.................... #ifndef NO 
.................... #define NO  0 
.................... #endif 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// Defines a 5x7 font 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... const unsigned int8 FONT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x00, 0x04, 0x02, 0x7F, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const unsigned int8 FONT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_line(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, iunsigned nt16 y2, int1 color) 
.................... #else 
.................... void glcd_line(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 color) 
.................... #endif 
*
03B9:  MOVLW  01
03BA:  BSF    03.5
03BB:  MOVWF  35
03BC:  MOVWF  36
03BD:  CLRF   3B
.................... { 
....................    unsigned int16        dy, dx; 
....................    signed int8  addx=1, addy=1; 
....................    signed int16 P, diff; 
....................  
....................    #ifdef LARGE_LCD 
....................    unsigned int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    unsigned int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
03BE:  MOVF   2C,W
03BF:  SUBWF  2E,W
03C0:  MOVWF  3C
03C1:  MOVF   3C,W
03C2:  BTFSS  3C.7
03C3:  GOTO   3C6
03C4:  MOVF   3C,W
03C5:  SUBLW  00
03C6:  CLRF   7A
03C7:  MOVWF  33
03C8:  MOVF   7A,W
03C9:  MOVWF  34
....................    dy = abs((signed int8)(y2 - y1)); 
03CA:  MOVF   2D,W
03CB:  SUBWF  2F,W
03CC:  MOVWF  3C
03CD:  MOVF   3C,W
03CE:  BTFSS  3C.7
03CF:  GOTO   3D2
03D0:  MOVF   3C,W
03D1:  SUBLW  00
03D2:  CLRF   7A
03D3:  MOVWF  31
03D4:  MOVF   7A,W
03D5:  MOVWF  32
....................    #endif 
....................  
....................    if(x1 > x2) 
03D6:  MOVF   2C,W
03D7:  SUBWF  2E,W
03D8:  BTFSC  03.0
03D9:  GOTO   3DC
....................       addx = -1; 
03DA:  MOVLW  FF
03DB:  MOVWF  35
....................    if(y1 > y2) 
03DC:  MOVF   2D,W
03DD:  SUBWF  2F,W
03DE:  BTFSC  03.0
03DF:  GOTO   3E2
....................       addy = -1; 
03E0:  MOVLW  FF
03E1:  MOVWF  36
....................  
....................    if(dx >= dy) 
03E2:  MOVF   32,W
03E3:  SUBWF  34,W
03E4:  BTFSS  03.0
03E5:  GOTO   430
03E6:  BTFSS  03.2
03E7:  GOTO   3EC
03E8:  MOVF   31,W
03E9:  SUBWF  33,W
03EA:  BTFSS  03.0
03EB:  GOTO   430
....................    { 
....................       dy *= 2; 
03EC:  BCF    03.0
03ED:  RLF    31,F
03EE:  RLF    32,F
....................       P = dy - dx; 
03EF:  MOVF   33,W
03F0:  SUBWF  31,W
03F1:  MOVWF  77
03F2:  MOVF   32,W
03F3:  MOVWF  7A
03F4:  MOVF   34,W
03F5:  BTFSS  03.0
03F6:  INCFSZ 34,W
03F7:  SUBWF  7A,F
03F8:  MOVF   77,W
03F9:  MOVWF  37
03FA:  MOVF   7A,W
03FB:  MOVWF  38
....................       diff = P - dx; 
03FC:  MOVF   33,W
03FD:  SUBWF  37,W
03FE:  MOVWF  39
03FF:  MOVF   38,W
0400:  MOVWF  3A
0401:  MOVF   34,W
0402:  BTFSS  03.0
0403:  INCFSZ 34,W
0404:  SUBWF  3A,F
....................  
....................       for(; i<=dx; ++i) 
0405:  MOVF   34,F
0406:  BTFSS  03.2
0407:  GOTO   40C
0408:  MOVF   3B,W
0409:  SUBWF  33,W
040A:  BTFSS  03.0
040B:  GOTO   42F
....................       { 
....................          glcd_pixel(x1, y1, color); 
040C:  MOVF   2C,W
040D:  MOVWF  3C
040E:  MOVF   2D,W
040F:  MOVWF  3D
0410:  MOVF   30,W
0411:  MOVWF  3E
0412:  BCF    03.5
0413:  CALL   337
....................  
....................          if(P < 0) 
0414:  BSF    03.5
0415:  BTFSS  38.7
0416:  GOTO   421
....................          { 
....................             P  += dy; 
0417:  MOVF   31,W
0418:  ADDWF  37,F
0419:  MOVF   32,W
041A:  BTFSC  03.0
041B:  INCFSZ 32,W
041C:  ADDWF  38,F
....................             x1 += addx; 
041D:  MOVF   35,W
041E:  ADDWF  2C,W
041F:  MOVWF  2C
....................          } 
0420:  GOTO   42D
....................          else 
....................          { 
....................             P  += diff; 
0421:  MOVF   39,W
0422:  ADDWF  37,F
0423:  MOVF   3A,W
0424:  BTFSC  03.0
0425:  INCFSZ 3A,W
0426:  ADDWF  38,F
....................             x1 += addx; 
0427:  MOVF   35,W
0428:  ADDWF  2C,W
0429:  MOVWF  2C
....................             y1 += addy; 
042A:  MOVF   36,W
042B:  ADDWF  2D,W
042C:  MOVWF  2D
....................          } 
042D:  INCF   3B,F
042E:  GOTO   405
....................       } 
....................    } 
042F:  GOTO   473
....................    else 
....................    { 
....................       dx *= 2; 
0430:  BCF    03.0
0431:  RLF    33,F
0432:  RLF    34,F
....................       P = dx - dy; 
0433:  MOVF   31,W
0434:  SUBWF  33,W
0435:  MOVWF  77
0436:  MOVF   34,W
0437:  MOVWF  7A
0438:  MOVF   32,W
0439:  BTFSS  03.0
043A:  INCFSZ 32,W
043B:  SUBWF  7A,F
043C:  MOVF   77,W
043D:  MOVWF  37
043E:  MOVF   7A,W
043F:  MOVWF  38
....................       diff = P - dy; 
0440:  MOVF   31,W
0441:  SUBWF  37,W
0442:  MOVWF  39
0443:  MOVF   38,W
0444:  MOVWF  3A
0445:  MOVF   32,W
0446:  BTFSS  03.0
0447:  INCFSZ 32,W
0448:  SUBWF  3A,F
....................  
....................       for(; i<=dy; ++i) 
0449:  MOVF   32,F
044A:  BTFSS  03.2
044B:  GOTO   450
044C:  MOVF   3B,W
044D:  SUBWF  31,W
044E:  BTFSS  03.0
044F:  GOTO   473
....................       { 
....................          glcd_pixel(x1, y1, color); 
0450:  MOVF   2C,W
0451:  MOVWF  3C
0452:  MOVF   2D,W
0453:  MOVWF  3D
0454:  MOVF   30,W
0455:  MOVWF  3E
0456:  BCF    03.5
0457:  CALL   337
....................  
....................          if(P < 0) 
0458:  BSF    03.5
0459:  BTFSS  38.7
045A:  GOTO   465
....................          { 
....................             P  += dx; 
045B:  MOVF   33,W
045C:  ADDWF  37,F
045D:  MOVF   34,W
045E:  BTFSC  03.0
045F:  INCFSZ 34,W
0460:  ADDWF  38,F
....................             y1 += addy; 
0461:  MOVF   36,W
0462:  ADDWF  2D,W
0463:  MOVWF  2D
....................          } 
0464:  GOTO   471
....................          else 
....................          { 
....................             P  += diff; 
0465:  MOVF   39,W
0466:  ADDWF  37,F
0467:  MOVF   3A,W
0468:  BTFSC  03.0
0469:  INCFSZ 3A,W
046A:  ADDWF  38,F
....................             x1 += addx; 
046B:  MOVF   35,W
046C:  ADDWF  2C,W
046D:  MOVWF  2C
....................             y1 += addy; 
046E:  MOVF   36,W
046F:  ADDWF  2D,W
0470:  MOVWF  2D
....................          } 
0471:  INCF   3B,F
0472:  GOTO   449
....................       } 
....................    } 
0473:  BCF    03.5
0474:  RETURN
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_rect(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, unsigned int16 y2, int1 fill, int1 color) 
.................... #else 
.................... void glcd_rect(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    if(fill) 
0475:  BSF    03.5
0476:  MOVF   25,F
0477:  BTFSC  03.2
0478:  GOTO   4AB
....................    { 
....................       #ifdef LARGE_LCD 
....................       unsigned int16 i, xmin, xmax, ymin, ymax; 
....................       #else 
....................       unsigned int8  i, xmin, xmax, ymin, ymax; 
....................       #endif 
....................  
....................       if(x1 < x2)                            //  Find x min and max 
0479:  MOVF   23,W
047A:  SUBWF  21,W
047B:  BTFSC  03.0
047C:  GOTO   482
....................       { 
....................          xmin = x1; 
047D:  MOVF   21,W
047E:  MOVWF  28
....................          xmax = x2; 
047F:  MOVF   23,W
0480:  MOVWF  29
....................       } 
0481:  GOTO   486
....................       else 
....................       { 
....................          xmin = x2; 
0482:  MOVF   23,W
0483:  MOVWF  28
....................          xmax = x1; 
0484:  MOVF   21,W
0485:  MOVWF  29
....................       } 
....................  
....................       if(y1 < y2)                            // Find the y min and max 
0486:  MOVF   24,W
0487:  SUBWF  22,W
0488:  BTFSC  03.0
0489:  GOTO   48F
....................       { 
....................          ymin = y1; 
048A:  MOVF   22,W
048B:  MOVWF  2A
....................          ymax = y2; 
048C:  MOVF   24,W
048D:  MOVWF  2B
....................       } 
048E:  GOTO   493
....................       else 
....................       { 
....................          ymin = y2; 
048F:  MOVF   24,W
0490:  MOVWF  2A
....................          ymax = y1; 
0491:  MOVF   22,W
0492:  MOVWF  2B
....................       } 
....................  
....................       for(; xmin <= xmax; ++xmin) 
0493:  MOVF   28,W
0494:  SUBWF  29,W
0495:  BTFSS  03.0
0496:  GOTO   4AA
....................       { 
....................          for(i=ymin; i<=ymax; ++i) 
0497:  MOVF   2A,W
0498:  MOVWF  27
0499:  MOVF   27,W
049A:  SUBWF  2B,W
049B:  BTFSS  03.0
049C:  GOTO   4A8
....................          { 
....................             glcd_pixel(xmin, i, color); 
049D:  MOVF   28,W
049E:  MOVWF  3C
049F:  MOVF   27,W
04A0:  MOVWF  3D
04A1:  MOVF   26,W
04A2:  MOVWF  3E
04A3:  BCF    03.5
04A4:  CALL   337
04A5:  BSF    03.5
04A6:  INCF   27,F
04A7:  GOTO   499
....................          } 
04A8:  INCF   28,F
04A9:  GOTO   493
....................       } 
....................    } 
04AA:  GOTO   4DF
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
04AB:  MOVF   21,W
04AC:  MOVWF  2C
04AD:  MOVF   22,W
04AE:  MOVWF  2D
04AF:  MOVF   23,W
04B0:  MOVWF  2E
04B1:  MOVF   22,W
04B2:  MOVWF  2F
04B3:  MOVF   26,W
04B4:  MOVWF  30
04B5:  BCF    03.5
04B6:  CALL   3B9
....................       glcd_line(x1, y2, x2, y2, color); 
04B7:  BSF    03.5
04B8:  MOVF   21,W
04B9:  MOVWF  2C
04BA:  MOVF   24,W
04BB:  MOVWF  2D
04BC:  MOVF   23,W
04BD:  MOVWF  2E
04BE:  MOVF   24,W
04BF:  MOVWF  2F
04C0:  MOVF   26,W
04C1:  MOVWF  30
04C2:  BCF    03.5
04C3:  CALL   3B9
....................       glcd_line(x1, y1, x1, y2, color); 
04C4:  BSF    03.5
04C5:  MOVF   21,W
04C6:  MOVWF  2C
04C7:  MOVF   22,W
04C8:  MOVWF  2D
04C9:  MOVF   21,W
04CA:  MOVWF  2E
04CB:  MOVF   24,W
04CC:  MOVWF  2F
04CD:  MOVF   26,W
04CE:  MOVWF  30
04CF:  BCF    03.5
04D0:  CALL   3B9
....................       glcd_line(x2, y1, x2, y2, color); 
04D1:  BSF    03.5
04D2:  MOVF   23,W
04D3:  MOVWF  2C
04D4:  MOVF   22,W
04D5:  MOVWF  2D
04D6:  MOVF   23,W
04D7:  MOVWF  2E
04D8:  MOVF   24,W
04D9:  MOVWF  2F
04DA:  MOVF   26,W
04DB:  MOVWF  30
04DC:  BCF    03.5
04DD:  CALL   3B9
04DE:  BSF    03.5
....................    } 
04DF:  BCF    03.5
04E0:  RETURN
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_bar(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, unsigned int16 y2, unsigned int8 width, int1 color) 
.................... #else 
.................... void glcd_bar(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, unsigned int8 width, int1 color) 
.................... #endif 
.................... { 
....................    unsigned int8         half_width; 
....................    signed int16 dy, dx; 
....................    signed int8  addx=1, addy=1, j; 
....................    signed int16 P, diff, c1, c2; 
....................  
....................    #ifdef LARGE_LCD 
....................    unsigned int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    unsigned int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
....................    dy = abs((signed int8)(y2 - y1)); 
....................    #endif 
....................  
....................    half_width = width/2; 
....................    c1 = -(dx*x1 + dy*y1); 
....................    c2 = -(dx*x2 + dy*y2); 
....................  
....................    if(x1 > x2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addx = -1; 
....................    } 
....................    if(y1 > y2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addy = -1; 
....................    } 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................       diff = P - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................                glcd_pixel(x1, y1+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dy; 
....................             x1 += addx; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................       diff = P - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dx; 
....................             y1 += addy; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................                glcd_pixel(x1+j, y1, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_circle(unsigned int16 x, unsigned int16 y, unsigned int16 radius, int1 fill, int1 color) 
.................... #else 
.................... void glcd_circle(unsigned int8 x, unsigned int8 y, unsigned int8 radius, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    #ifdef LARGE_LCD 
....................    signed int16 a, b, P; 
....................    #else 
....................    signed int8  a, b, P; 
....................    #endif 
....................  
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P += 3 + 2 * a++; 
....................       else 
....................          P += 5 + 2 * (a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_text57(unsigned int16 x, unsigned int16 y, char* textptr, unsigned int8 size, int1 color) 
.................... #else 
.................... void glcd_text57(unsigned int8 x, unsigned int8 y, char* textptr, unsigned int8 size, int1 color) 
.................... #endif 
.................... { 
....................    unsigned int8 j, k, l, m;                       // Loop counters 
....................    unsigned int8 pixelData[5];                     // Stores character data 
....................  
....................    for(; *textptr != '\0'; ++textptr, ++x)// Loop through the passed string 
04E1:  BSF    03.5
04E2:  MOVF   23,W
04E3:  MOVWF  7A
04E4:  MOVF   22,W
04E5:  MOVWF  04
04E6:  BCF    03.7
04E7:  BTFSC  7A.0
04E8:  BSF    03.7
04E9:  MOVF   00,F
04EA:  BTFSC  03.2
04EB:  GOTO   5D7
....................    { 
....................       if(*textptr < 'S') // Checks if the letter is in the first font array 
04EC:  MOVF   23,W
04ED:  MOVWF  7A
04EE:  MOVF   22,W
04EF:  MOVWF  04
04F0:  BCF    03.7
04F1:  BTFSC  7A.0
04F2:  BSF    03.7
04F3:  MOVF   00,W
04F4:  SUBLW  52
04F5:  BTFSS  03.0
04F6:  GOTO   51C
....................          memcpy(pixelData, FONT[*textptr - ' '], 5); 
04F7:  MOVF   23,W
04F8:  MOVWF  7A
04F9:  MOVF   22,W
04FA:  MOVWF  04
04FB:  BCF    03.7
04FC:  BTFSC  7A.0
04FD:  BSF    03.7
04FE:  MOVLW  20
04FF:  SUBWF  00,W
0500:  MOVWF  30
0501:  MOVWF  31
0502:  MOVLW  05
0503:  MOVWF  32
0504:  BCF    03.5
0505:  CALL   215
0506:  MOVF   78,W
0507:  BSF    03.5
0508:  MOVWF  2F
0509:  MOVWF  78
050A:  MOVLW  05
050B:  MOVWF  77
050C:  MOVLW  AA
050D:  MOVWF  04
050E:  BCF    03.7
050F:  MOVF   78,W
0510:  BCF    03.5
0511:  CALL   004
0512:  MOVWF  00
0513:  INCF   78,F
0514:  INCF   04,F
0515:  DECFSZ 77,F
0516:  GOTO   518
0517:  GOTO   51A
0518:  BSF    03.5
0519:  GOTO   50F
051A:  GOTO   552
051B:  BSF    03.5
....................       else if(*textptr <= '~') // Check if the letter is in the second font array 
051C:  MOVF   23,W
051D:  MOVWF  7A
051E:  MOVF   22,W
051F:  MOVWF  04
0520:  BCF    03.7
0521:  BTFSC  7A.0
0522:  BSF    03.7
0523:  MOVF   00,W
0524:  SUBLW  7E
0525:  BTFSS  03.0
0526:  GOTO   54C
....................          memcpy(pixelData, FONT2[*textptr - 'S'], 5); 
0527:  MOVF   23,W
0528:  MOVWF  7A
0529:  MOVF   22,W
052A:  MOVWF  04
052B:  BCF    03.7
052C:  BTFSC  7A.0
052D:  BSF    03.7
052E:  MOVLW  53
052F:  SUBWF  00,W
0530:  MOVWF  30
0531:  MOVWF  31
0532:  MOVLW  05
0533:  MOVWF  32
0534:  BCF    03.5
0535:  CALL   215
0536:  MOVF   78,W
0537:  BSF    03.5
0538:  MOVWF  2F
0539:  MOVWF  78
053A:  MOVLW  05
053B:  MOVWF  77
053C:  MOVLW  AA
053D:  MOVWF  04
053E:  BCF    03.7
053F:  MOVF   78,W
0540:  BCF    03.5
0541:  CALL   10A
0542:  MOVWF  00
0543:  INCF   78,F
0544:  INCF   04,F
0545:  DECFSZ 77,F
0546:  GOTO   548
0547:  GOTO   54A
0548:  BSF    03.5
0549:  GOTO   53F
054A:  GOTO   552
054B:  BSF    03.5
....................       else 
....................          memcpy(pixelData, FONT[0], 5);   // Default to space 
054C:  CLRF   2A
054D:  CLRF   2B
054E:  CLRF   2C
054F:  CLRF   2D
0550:  CLRF   2E
0551:  BCF    03.5
....................  
....................       // Handles newline and carriage returns 
....................       switch(*textptr) 
0552:  BSF    03.5
0553:  MOVF   23,W
0554:  MOVWF  7A
0555:  MOVF   22,W
0556:  MOVWF  04
0557:  BCF    03.7
0558:  BTFSC  7A.0
0559:  BSF    03.7
055A:  MOVF   00,W
055B:  XORLW  0A
055C:  BCF    03.5
055D:  BTFSC  03.2
055E:  GOTO   563
055F:  XORLW  07
0560:  BTFSC  03.2
0561:  GOTO   570
0562:  GOTO   574
....................       { 
....................          case '\n': 
....................             y += 7*size + 1; 
0563:  MOVLW  07
0564:  BSF    03.5
0565:  MOVWF  31
0566:  MOVF   24,W
0567:  MOVWF  32
0568:  BCF    03.5
0569:  CALL   215
056A:  MOVLW  01
056B:  ADDWF  78,W
056C:  BSF    03.5
056D:  ADDWF  21,F
....................             continue; 
056E:  GOTO   5D2
056F:  BCF    03.5
....................          case '\r': 
....................             x = 0; 
0570:  BSF    03.5
0571:  CLRF   20
....................             continue; 
0572:  GOTO   5D2
0573:  BCF    03.5
....................       } 
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
0574:  MOVLW  05
0575:  BSF    03.5
0576:  MOVWF  31
0577:  MOVF   24,W
0578:  MOVWF  32
0579:  BCF    03.5
057A:  CALL   215
057B:  MOVF   78,W
057C:  BSF    03.5
057D:  ADDWF  20,W
057E:  SUBLW  7F
057F:  BTFSC  03.0
0580:  GOTO   58C
....................       { 
....................          x = 0;                           // Set x at far left position 
0581:  CLRF   20
....................          y += 7*size + 1;                 // Set y at next position down 
0582:  MOVLW  07
0583:  MOVWF  31
0584:  MOVF   24,W
0585:  MOVWF  32
0586:  BCF    03.5
0587:  CALL   215
0588:  MOVLW  01
0589:  ADDWF  78,W
058A:  BSF    03.5
058B:  ADDWF  21,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
058C:  CLRF   26
058D:  MOVF   26,W
058E:  SUBLW  04
058F:  BTFSS  03.0
0590:  GOTO   5D2
....................       { 
....................          for(k=0; k < 7; ++k)             // Loop through the vertical pixels 
0591:  CLRF   27
0592:  MOVF   27,W
0593:  SUBLW  06
0594:  BTFSS  03.0
0595:  GOTO   5CE
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
0596:  MOVLW  AA
0597:  ADDWF  26,W
0598:  MOVWF  04
0599:  BCF    03.7
059A:  MOVF   00,W
059B:  MOVWF  2F
059C:  MOVWF  77
059D:  MOVF   27,W
059E:  MOVWF  78
059F:  BTFSC  03.2
05A0:  GOTO   5A5
05A1:  BCF    03.0
05A2:  RRF    77,F
05A3:  DECFSZ 78,F
05A4:  GOTO   5A1
05A5:  BTFSS  77.0
05A6:  GOTO   5CC
....................             { 
....................                for(l=0; l < size; ++l)    // These two loops change the 
05A7:  CLRF   28
05A8:  MOVF   24,W
05A9:  SUBWF  28,W
05AA:  BTFSC  03.0
05AB:  GOTO   5CC
....................                {                          // character's size 
....................                   for(m=0; m < size; ++m) 
05AC:  CLRF   29
05AD:  MOVF   24,W
05AE:  SUBWF  29,W
05AF:  BTFSC  03.0
05B0:  GOTO   5CA
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
05B1:  MOVF   29,W
05B2:  ADDWF  20,W
05B3:  MOVWF  2F
05B4:  MOVF   27,W
05B5:  MOVWF  31
05B6:  MOVF   24,W
05B7:  MOVWF  32
05B8:  BCF    03.5
05B9:  CALL   215
05BA:  MOVF   78,W
05BB:  BSF    03.5
05BC:  ADDWF  21,W
05BD:  ADDWF  28,W
05BE:  MOVWF  30
05BF:  MOVF   2F,W
05C0:  MOVWF  3C
05C1:  MOVF   30,W
05C2:  MOVWF  3D
05C3:  MOVF   25,W
05C4:  MOVWF  3E
05C5:  BCF    03.5
05C6:  CALL   337
05C7:  BSF    03.5
05C8:  INCF   29,F
05C9:  GOTO   5AD
....................                   } 
05CA:  INCF   28,F
05CB:  GOTO   5A8
....................                } 
....................             } 
05CC:  INCF   27,F
05CD:  GOTO   592
....................          } 
05CE:  INCF   26,F
05CF:  MOVF   24,W
05D0:  ADDWF  20,F
05D1:  GOTO   58D
....................       } 
05D2:  INCF   22,F
05D3:  BTFSC  03.2
05D4:  INCF   23,F
05D5:  INCF   20,F
05D6:  GOTO   4E2
....................    } 
05D7:  BCF    03.5
05D8:  RETURN
.................... } 
....................  
.................... #endif 
....................  
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
079D:  BSF    03.5
079E:  MOVF   21,W
079F:  MOVWF  7A
07A0:  MOVF   20,W
07A1:  MOVWF  04
07A2:  BCF    03.7
07A3:  BTFSC  7A.0
07A4:  BSF    03.7
07A5:  MOVF   00,W
07A6:  MOVWF  24
07A7:  MOVF   23,W
07A8:  MOVWF  7A
07A9:  MOVF   22,W
07AA:  MOVWF  04
07AB:  BCF    03.7
07AC:  BTFSC  7A.0
07AD:  BSF    03.7
07AE:  MOVF   00,W
07AF:  SUBWF  24,W
07B0:  BTFSS  03.2
07B1:  GOTO   7C9
....................       if (*s1 == '\0') 
07B2:  MOVF   21,W
07B3:  MOVWF  7A
07B4:  MOVF   20,W
07B5:  MOVWF  04
07B6:  BCF    03.7
07B7:  BTFSC  7A.0
07B8:  BSF    03.7
07B9:  MOVF   00,F
07BA:  BTFSS  03.2
07BB:  GOTO   7BF
....................          return(0); 
07BC:  MOVLW  00
07BD:  MOVWF  78
07BE:  GOTO   7E1
07BF:  MOVF   21,W
07C0:  MOVWF  7A
07C1:  MOVF   20,W
07C2:  INCF   20,F
07C3:  BTFSC  03.2
07C4:  INCF   21,F
07C5:  INCF   22,F
07C6:  BTFSC  03.2
07C7:  INCF   23,F
07C8:  GOTO   79E
....................    return((*s1 < *s2) ? -1: 1); 
07C9:  MOVF   21,W
07CA:  MOVWF  7A
07CB:  MOVF   20,W
07CC:  MOVWF  04
07CD:  BCF    03.7
07CE:  BTFSC  21.0
07CF:  BSF    03.7
07D0:  MOVF   00,W
07D1:  MOVWF  24
07D2:  MOVF   23,W
07D3:  MOVWF  7A
07D4:  MOVF   22,W
07D5:  MOVWF  04
07D6:  BCF    03.7
07D7:  BTFSC  23.0
07D8:  BSF    03.7
07D9:  MOVF   00,W
07DA:  SUBWF  24,W
07DB:  BTFSC  03.0
07DC:  GOTO   7DF
07DD:  MOVLW  FF
07DE:  GOTO   7E0
07DF:  MOVLW  01
07E0:  MOVWF  78
07E1:  BCF    03.5
07E2:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0A7A:  BCF    03.5
0A7B:  CLRF   21
0A7C:  CLRF   22
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... char name[] ="Embedded Lab"; 
0A7D:  MOVLW  45
0A7E:  MOVWF  27
0A7F:  MOVLW  6D
0A80:  MOVWF  28
0A81:  MOVLW  62
0A82:  MOVWF  29
0A83:  MOVLW  65
0A84:  MOVWF  2A
0A85:  MOVLW  64
0A86:  MOVWF  2B
0A87:  MOVWF  2C
0A88:  MOVLW  65
0A89:  MOVWF  2D
0A8A:  MOVLW  64
0A8B:  MOVWF  2E
0A8C:  MOVLW  20
0A8D:  MOVWF  2F
0A8E:  MOVLW  4C
0A8F:  MOVWF  30
0A90:  MOVLW  61
0A91:  MOVWF  31
0A92:  MOVLW  62
0A93:  MOVWF  32
0A94:  CLRF   33
.................... char Text[] ="Pressure sensor"; 
0A95:  MOVLW  50
0A96:  MOVWF  34
0A97:  MOVLW  72
0A98:  MOVWF  35
0A99:  MOVLW  65
0A9A:  MOVWF  36
0A9B:  MOVLW  73
0A9C:  MOVWF  37
0A9D:  MOVWF  38
0A9E:  MOVLW  75
0A9F:  MOVWF  39
0AA0:  MOVLW  72
0AA1:  MOVWF  3A
0AA2:  MOVLW  65
0AA3:  MOVWF  3B
0AA4:  MOVLW  20
0AA5:  MOVWF  3C
0AA6:  MOVLW  73
0AA7:  MOVWF  3D
0AA8:  MOVLW  65
0AA9:  MOVWF  3E
0AAA:  MOVLW  6E
0AAB:  MOVWF  3F
0AAC:  MOVLW  73
0AAD:  MOVWF  40
0AAE:  MOVLW  6F
0AAF:  MOVWF  41
0AB0:  MOVLW  72
0AB1:  MOVWF  42
0AB2:  CLRF   43
.................... double value; 
.................... double per; 
.................... void main(){ 
*
0A6B:  MOVF   03,W
0A6C:  ANDLW  1F
0A6D:  MOVWF  03
0A6E:  MOVLW  FF
0A6F:  MOVWF  20
0A70:  CLRF   4D
0A71:  CLRF   4C
0A72:  BSF    03.5
0A73:  BSF    1F.0
0A74:  BSF    1F.1
0A75:  BSF    1F.2
0A76:  BCF    1F.3
0A77:  MOVLW  07
0A78:  MOVWF  1C
0A79:  BCF    03.7
.................... setup_adc(ADC_CLOCK_INTERNAL); 
*
0AB3:  BSF    03.5
0AB4:  BCF    1F.6
0AB5:  BCF    03.5
0AB6:  BSF    1F.6
0AB7:  BSF    1F.7
0AB8:  BSF    03.5
0AB9:  BSF    1F.7
0ABA:  BCF    03.5
0ABB:  BSF    1F.0
.................... setup_adc_ports(ALL_ANALOG); 
0ABC:  BSF    03.5
0ABD:  BCF    1F.0
0ABE:  BCF    1F.1
0ABF:  BCF    1F.2
0AC0:  BCF    1F.3
....................  
.................... glcd_init(on); 
0AC1:  MOVLW  01
0AC2:  MOVWF  20
0AC3:  BCF    0A.3
0AC4:  BCF    03.5
0AC5:  GOTO   23C
0AC6:  BSF    0A.3
.................... delay_ms(10); 
0AC7:  MOVLW  0A
0AC8:  BSF    03.5
0AC9:  MOVWF  20
0ACA:  BCF    0A.3
0ACB:  BCF    03.5
0ACC:  GOTO   2F1
0ACD:  BSF    0A.3
.................... glcd_rect(97,0,127,63,OFF,ON); 
0ACE:  MOVLW  61
0ACF:  BSF    03.5
0AD0:  MOVWF  21
0AD1:  CLRF   22
0AD2:  MOVLW  7F
0AD3:  MOVWF  23
0AD4:  MOVLW  3F
0AD5:  MOVWF  24
0AD6:  CLRF   25
0AD7:  MOVLW  01
0AD8:  MOVWF  26
0AD9:  BCF    0A.3
0ADA:  BCF    03.5
0ADB:  CALL   475
0ADC:  BSF    0A.3
.................... glcd_text57(0,0,text,1.5,on); 
0ADD:  BSF    03.5
0ADE:  CLRF   20
0ADF:  CLRF   21
0AE0:  CLRF   23
0AE1:  MOVLW  34
0AE2:  MOVWF  22
0AE3:  MOVLW  01
0AE4:  MOVWF  24
0AE5:  MOVWF  25
0AE6:  BCF    0A.3
0AE7:  BCF    03.5
0AE8:  CALL   4E1
0AE9:  BSF    0A.3
.................... glcd_text57(0,20,name,1.5,on); 
0AEA:  BSF    03.5
0AEB:  CLRF   20
0AEC:  MOVLW  14
0AED:  MOVWF  21
0AEE:  CLRF   23
0AEF:  MOVLW  27
0AF0:  MOVWF  22
0AF1:  MOVLW  01
0AF2:  MOVWF  24
0AF3:  MOVWF  25
0AF4:  BCF    0A.3
0AF5:  BCF    03.5
0AF6:  CALL   4E1
0AF7:  BSF    0A.3
.................... char value1 [20]; 
.................... char value2 [20]; 
.................... set_adc_channel(0); 
0AF8:  MOVLW  00
0AF9:  MOVWF  78
0AFA:  MOVF   1F,W
0AFB:  ANDLW  C7
0AFC:  IORWF  78,W
0AFD:  MOVWF  1F
....................  
.................... while(1){ 
....................  
....................  
.................... value=((read_adc()*(5.0/1024.0)/5) + 0.095)/0.009; 
0AFE:  BSF    1F.2
0AFF:  BTFSC  1F.2
0B00:  GOTO   2FF
0B01:  MOVF   1E,W
0B02:  MOVWF  7A
0B03:  BSF    03.5
0B04:  MOVF   1E,W
0B05:  MOVWF  20
0B06:  MOVF   7A,W
0B07:  MOVWF  21
0B08:  MOVWF  23
0B09:  MOVF   1E,W
0B0A:  MOVWF  22
0B0B:  BCF    0A.3
0B0C:  BCF    03.5
0B0D:  GOTO   5D9
0B0E:  BSF    0A.3
0B0F:  MOVF   7A,W
0B10:  BSF    03.5
0B11:  MOVWF  30
0B12:  MOVF   79,W
0B13:  MOVWF  2F
0B14:  MOVF   78,W
0B15:  MOVWF  2E
0B16:  MOVF   77,W
0B17:  MOVWF  2D
0B18:  CLRF   34
0B19:  CLRF   33
0B1A:  MOVLW  20
0B1B:  MOVWF  32
0B1C:  MOVLW  77
0B1D:  MOVWF  31
0B1E:  BCF    0A.3
0B1F:  BCF    03.5
0B20:  CALL   5FA
0B21:  BSF    0A.3
0B22:  MOVF   7A,W
0B23:  BSF    03.5
0B24:  MOVWF  23
0B25:  MOVF   79,W
0B26:  MOVWF  22
0B27:  MOVF   78,W
0B28:  MOVWF  21
0B29:  MOVF   77,W
0B2A:  MOVWF  20
0B2B:  MOVF   23,W
0B2C:  MOVWF  27
0B2D:  MOVF   22,W
0B2E:  MOVWF  26
0B2F:  MOVF   21,W
0B30:  MOVWF  25
0B31:  MOVF   20,W
0B32:  MOVWF  24
0B33:  CLRF   2B
0B34:  CLRF   2A
0B35:  MOVLW  20
0B36:  MOVWF  29
0B37:  MOVLW  81
0B38:  MOVWF  28
0B39:  BCF    0A.3
0B3A:  BCF    03.5
0B3B:  CALL   671
0B3C:  BSF    0A.3
0B3D:  MOVF   7A,W
0B3E:  BSF    03.5
0B3F:  MOVWF  23
0B40:  MOVF   79,W
0B41:  MOVWF  22
0B42:  MOVF   78,W
0B43:  MOVWF  21
0B44:  MOVF   77,W
0B45:  MOVWF  20
0B46:  BCF    03.1
0B47:  MOVF   23,W
0B48:  MOVWF  27
0B49:  MOVF   22,W
0B4A:  MOVWF  26
0B4B:  MOVF   21,W
0B4C:  MOVWF  25
0B4D:  MOVF   20,W
0B4E:  MOVWF  24
0B4F:  MOVLW  5C
0B50:  MOVWF  2B
0B51:  MOVLW  8F
0B52:  MOVWF  2A
0B53:  MOVLW  42
0B54:  MOVWF  29
0B55:  MOVLW  7B
0B56:  MOVWF  28
0B57:  BCF    03.5
0B58:  CALL   000
0B59:  MOVF   7A,W
0B5A:  BSF    03.5
0B5B:  MOVWF  23
0B5C:  MOVF   79,W
0B5D:  MOVWF  22
0B5E:  MOVF   78,W
0B5F:  MOVWF  21
0B60:  MOVF   77,W
0B61:  MOVWF  20
0B62:  MOVF   23,W
0B63:  MOVWF  27
0B64:  MOVF   22,W
0B65:  MOVWF  26
0B66:  MOVF   21,W
0B67:  MOVWF  25
0B68:  MOVF   20,W
0B69:  MOVWF  24
0B6A:  MOVLW  BC
0B6B:  MOVWF  2B
0B6C:  MOVLW  74
0B6D:  MOVWF  2A
0B6E:  MOVLW  13
0B6F:  MOVWF  29
0B70:  MOVLW  78
0B71:  MOVWF  28
0B72:  BCF    0A.3
0B73:  BCF    03.5
0B74:  CALL   671
0B75:  BSF    0A.3
0B76:  MOVF   7A,W
0B77:  MOVWF  47
0B78:  MOVF   79,W
0B79:  MOVWF  46
0B7A:  MOVF   78,W
0B7B:  MOVWF  45
0B7C:  MOVF   77,W
0B7D:  MOVWF  44
.................... value=value-1.4; 
0B7E:  BSF    03.1
0B7F:  MOVF   47,W
0B80:  BSF    03.5
0B81:  MOVWF  27
0B82:  BCF    03.5
0B83:  MOVF   46,W
0B84:  BSF    03.5
0B85:  MOVWF  26
0B86:  BCF    03.5
0B87:  MOVF   45,W
0B88:  BSF    03.5
0B89:  MOVWF  25
0B8A:  BCF    03.5
0B8B:  MOVF   44,W
0B8C:  BSF    03.5
0B8D:  MOVWF  24
0B8E:  MOVLW  33
0B8F:  MOVWF  2B
0B90:  MOVWF  2A
0B91:  MOVWF  29
0B92:  MOVLW  7F
0B93:  MOVWF  28
0B94:  BCF    03.5
0B95:  CALL   000
0B96:  MOVF   7A,W
0B97:  MOVWF  47
0B98:  MOVF   79,W
0B99:  MOVWF  46
0B9A:  MOVF   78,W
0B9B:  MOVWF  45
0B9C:  MOVF   77,W
0B9D:  MOVWF  44
.................... Sprintf(value1,"%fKPa",value); 
0B9E:  CLRF   4D
0B9F:  MOVLW  4E
0BA0:  MOVWF  4C
0BA1:  MOVLW  89
0BA2:  MOVWF  04
0BA3:  MOVF   47,W
0BA4:  BSF    03.5
0BA5:  MOVWF  23
0BA6:  BCF    03.5
0BA7:  MOVF   46,W
0BA8:  BSF    03.5
0BA9:  MOVWF  22
0BAA:  BCF    03.5
0BAB:  MOVF   45,W
0BAC:  BSF    03.5
0BAD:  MOVWF  21
0BAE:  BCF    03.5
0BAF:  MOVF   44,W
0BB0:  BSF    03.5
0BB1:  MOVWF  20
0BB2:  MOVLW  02
0BB3:  MOVWF  24
0BB4:  BCF    03.5
0BB5:  GOTO   146
0BB6:  MOVLW  4B
0BB7:  BSF    03.5
0BB8:  MOVWF  2D
0BB9:  BCF    0A.3
0BBA:  BCF    03.5
0BBB:  CALL   78E
0BBC:  BSF    0A.3
0BBD:  MOVLW  50
0BBE:  BSF    03.5
0BBF:  MOVWF  2D
0BC0:  BCF    0A.3
0BC1:  BCF    03.5
0BC2:  CALL   78E
0BC3:  BSF    0A.3
0BC4:  MOVLW  61
0BC5:  BSF    03.5
0BC6:  MOVWF  2D
0BC7:  BCF    0A.3
0BC8:  BCF    03.5
0BC9:  CALL   78E
0BCA:  BSF    0A.3
....................  
.................... if(strcmp(value1,value2)) 
0BCB:  BSF    03.5
0BCC:  CLRF   21
0BCD:  MOVLW  4E
0BCE:  MOVWF  20
0BCF:  CLRF   23
0BD0:  MOVLW  62
0BD1:  MOVWF  22
0BD2:  BCF    0A.3
0BD3:  BCF    03.5
0BD4:  CALL   79D
0BD5:  BSF    0A.3
0BD6:  MOVF   78,F
0BD7:  BTFSC  03.2
0BD8:  GOTO   3E7
.................... glcd_text57(0,40,value2,2,off); 
0BD9:  BSF    03.5
0BDA:  CLRF   20
0BDB:  MOVLW  28
0BDC:  MOVWF  21
0BDD:  CLRF   23
0BDE:  MOVLW  62
0BDF:  MOVWF  22
0BE0:  MOVLW  02
0BE1:  MOVWF  24
0BE2:  CLRF   25
0BE3:  BCF    0A.3
0BE4:  BCF    03.5
0BE5:  CALL   4E1
0BE6:  BSF    0A.3
....................  
.................... glcd_text57(0,40,value1,2,on); 
0BE7:  BSF    03.5
0BE8:  CLRF   20
0BE9:  MOVLW  28
0BEA:  MOVWF  21
0BEB:  CLRF   23
0BEC:  MOVLW  4E
0BED:  MOVWF  22
0BEE:  MOVLW  02
0BEF:  MOVWF  24
0BF0:  MOVLW  01
0BF1:  MOVWF  25
0BF2:  BCF    0A.3
0BF3:  BCF    03.5
0BF4:  CALL   4E1
0BF5:  BSF    0A.3
....................  
.................... per= (value/120)*100; 
0BF6:  MOVF   47,W
0BF7:  BSF    03.5
0BF8:  MOVWF  27
0BF9:  BCF    03.5
0BFA:  MOVF   46,W
0BFB:  BSF    03.5
0BFC:  MOVWF  26
0BFD:  BCF    03.5
0BFE:  MOVF   45,W
0BFF:  BSF    03.5
0C00:  MOVWF  25
0C01:  BCF    03.5
0C02:  MOVF   44,W
0C03:  BSF    03.5
0C04:  MOVWF  24
0C05:  CLRF   2B
0C06:  CLRF   2A
0C07:  MOVLW  70
0C08:  MOVWF  29
0C09:  MOVLW  85
0C0A:  MOVWF  28
0C0B:  BCF    0A.3
0C0C:  BCF    03.5
0C0D:  CALL   671
0C0E:  BSF    0A.3
0C0F:  MOVF   7A,W
0C10:  BSF    03.5
0C11:  MOVWF  23
0C12:  MOVF   79,W
0C13:  MOVWF  22
0C14:  MOVF   78,W
0C15:  MOVWF  21
0C16:  MOVF   77,W
0C17:  MOVWF  20
0C18:  MOVF   23,W
0C19:  MOVWF  30
0C1A:  MOVF   22,W
0C1B:  MOVWF  2F
0C1C:  MOVF   21,W
0C1D:  MOVWF  2E
0C1E:  MOVF   20,W
0C1F:  MOVWF  2D
0C20:  CLRF   34
0C21:  CLRF   33
0C22:  MOVLW  48
0C23:  MOVWF  32
0C24:  MOVLW  85
0C25:  MOVWF  31
0C26:  BCF    0A.3
0C27:  BCF    03.5
0C28:  CALL   5FA
0C29:  BSF    0A.3
0C2A:  MOVF   7A,W
0C2B:  MOVWF  4B
0C2C:  MOVF   79,W
0C2D:  MOVWF  4A
0C2E:  MOVF   78,W
0C2F:  MOVWF  49
0C30:  MOVF   77,W
0C31:  MOVWF  48
.................... per = 62*per/100; 
0C32:  BSF    03.5
0C33:  CLRF   30
0C34:  CLRF   2F
0C35:  MOVLW  78
0C36:  MOVWF  2E
0C37:  MOVLW  84
0C38:  MOVWF  2D
0C39:  BCF    03.5
0C3A:  MOVF   4B,W
0C3B:  BSF    03.5
0C3C:  MOVWF  34
0C3D:  BCF    03.5
0C3E:  MOVF   4A,W
0C3F:  BSF    03.5
0C40:  MOVWF  33
0C41:  BCF    03.5
0C42:  MOVF   49,W
0C43:  BSF    03.5
0C44:  MOVWF  32
0C45:  BCF    03.5
0C46:  MOVF   48,W
0C47:  BSF    03.5
0C48:  MOVWF  31
0C49:  BCF    0A.3
0C4A:  BCF    03.5
0C4B:  CALL   5FA
0C4C:  BSF    0A.3
0C4D:  MOVF   7A,W
0C4E:  BSF    03.5
0C4F:  MOVWF  23
0C50:  MOVF   79,W
0C51:  MOVWF  22
0C52:  MOVF   78,W
0C53:  MOVWF  21
0C54:  MOVF   77,W
0C55:  MOVWF  20
0C56:  MOVF   23,W
0C57:  MOVWF  27
0C58:  MOVF   22,W
0C59:  MOVWF  26
0C5A:  MOVF   21,W
0C5B:  MOVWF  25
0C5C:  MOVF   20,W
0C5D:  MOVWF  24
0C5E:  CLRF   2B
0C5F:  CLRF   2A
0C60:  MOVLW  48
0C61:  MOVWF  29
0C62:  MOVLW  85
0C63:  MOVWF  28
0C64:  BCF    0A.3
0C65:  BCF    03.5
0C66:  CALL   671
0C67:  BSF    0A.3
0C68:  MOVF   7A,W
0C69:  MOVWF  4B
0C6A:  MOVF   79,W
0C6B:  MOVWF  4A
0C6C:  MOVF   78,W
0C6D:  MOVWF  49
0C6E:  MOVF   77,W
0C6F:  MOVWF  48
....................  
....................  
.................... if(strcmp(value1,value2)){ 
0C70:  BSF    03.5
0C71:  CLRF   21
0C72:  MOVLW  4E
0C73:  MOVWF  20
0C74:  CLRF   23
0C75:  MOVLW  62
0C76:  MOVWF  22
0C77:  BCF    0A.3
0C78:  BCF    03.5
0C79:  CALL   79D
0C7A:  BSF    0A.3
0C7B:  MOVF   78,F
0C7C:  BTFSC  03.2
0C7D:  GOTO   4B5
.................... glcd_rect(98,62-per,126,62,YES,ON); 
0C7E:  BSF    03.1
0C7F:  BSF    03.5
0C80:  CLRF   27
0C81:  CLRF   26
0C82:  MOVLW  78
0C83:  MOVWF  25
0C84:  MOVLW  84
0C85:  MOVWF  24
0C86:  BCF    03.5
0C87:  MOVF   4B,W
0C88:  BSF    03.5
0C89:  MOVWF  2B
0C8A:  BCF    03.5
0C8B:  MOVF   4A,W
0C8C:  BSF    03.5
0C8D:  MOVWF  2A
0C8E:  BCF    03.5
0C8F:  MOVF   49,W
0C90:  BSF    03.5
0C91:  MOVWF  29
0C92:  BCF    03.5
0C93:  MOVF   48,W
0C94:  BSF    03.5
0C95:  MOVWF  28
0C96:  BCF    03.5
0C97:  CALL   000
0C98:  MOVF   7A,W
0C99:  BSF    03.5
0C9A:  MOVWF  23
0C9B:  MOVF   79,W
0C9C:  MOVWF  22
0C9D:  MOVF   78,W
0C9E:  MOVWF  21
0C9F:  MOVF   77,W
0CA0:  MOVWF  20
0CA1:  BCF    03.5
0CA2:  CALL   24A
0CA3:  MOVF   78,W
0CA4:  BSF    03.5
0CA5:  MOVWF  20
0CA6:  MOVLW  62
0CA7:  MOVWF  21
0CA8:  MOVF   20,W
0CA9:  MOVWF  22
0CAA:  MOVLW  7E
0CAB:  MOVWF  23
0CAC:  MOVLW  3E
0CAD:  MOVWF  24
0CAE:  MOVLW  01
0CAF:  MOVWF  25
0CB0:  MOVWF  26
0CB1:  BCF    0A.3
0CB2:  BCF    03.5
0CB3:  CALL   475
0CB4:  BSF    0A.3
....................  
.................... } 
....................  
....................  
.................... glcd_rect(98,1,126,62-per,YES,off); 
0CB5:  BSF    03.1
0CB6:  BSF    03.5
0CB7:  CLRF   27
0CB8:  CLRF   26
0CB9:  MOVLW  78
0CBA:  MOVWF  25
0CBB:  MOVLW  84
0CBC:  MOVWF  24
0CBD:  BCF    03.5
0CBE:  MOVF   4B,W
0CBF:  BSF    03.5
0CC0:  MOVWF  2B
0CC1:  BCF    03.5
0CC2:  MOVF   4A,W
0CC3:  BSF    03.5
0CC4:  MOVWF  2A
0CC5:  BCF    03.5
0CC6:  MOVF   49,W
0CC7:  BSF    03.5
0CC8:  MOVWF  29
0CC9:  BCF    03.5
0CCA:  MOVF   48,W
0CCB:  BSF    03.5
0CCC:  MOVWF  28
0CCD:  BCF    03.5
0CCE:  CALL   000
0CCF:  MOVF   7A,W
0CD0:  BSF    03.5
0CD1:  MOVWF  23
0CD2:  MOVF   79,W
0CD3:  MOVWF  22
0CD4:  MOVF   78,W
0CD5:  MOVWF  21
0CD6:  MOVF   77,W
0CD7:  MOVWF  20
0CD8:  BCF    03.5
0CD9:  CALL   24A
0CDA:  MOVF   78,W
0CDB:  BSF    03.5
0CDC:  MOVWF  20
0CDD:  MOVLW  62
0CDE:  MOVWF  21
0CDF:  MOVLW  01
0CE0:  MOVWF  22
0CE1:  MOVLW  7E
0CE2:  MOVWF  23
0CE3:  MOVF   20,W
0CE4:  MOVWF  24
0CE5:  MOVLW  01
0CE6:  MOVWF  25
0CE7:  CLRF   26
0CE8:  BCF    0A.3
0CE9:  BCF    03.5
0CEA:  CALL   475
0CEB:  BSF    0A.3
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... strcpy(value2, value1); 
0CEC:  BSF    03.5
0CED:  CLRF   23
0CEE:  MOVLW  4E
0CEF:  MOVWF  22
0CF0:  CLRF   21
0CF1:  MOVLW  62
0CF2:  MOVWF  20
0CF3:  MOVF   22,W
0CF4:  MOVWF  04
0CF5:  BCF    03.7
0CF6:  BTFSC  23.0
0CF7:  BSF    03.7
0CF8:  MOVF   00,W
0CF9:  MOVWF  24
0CFA:  MOVF   20,W
0CFB:  MOVWF  04
0CFC:  BCF    03.7
0CFD:  BTFSC  21.0
0CFE:  BSF    03.7
0CFF:  MOVF   24,W
0D00:  MOVWF  00
0D01:  MOVF   00,F
0D02:  BTFSC  03.2
0D03:  GOTO   507
0D04:  INCF   20,F
0D05:  INCF   22,F
0D06:  GOTO   4F3
0D07:  BCF    03.5
0D08:  GOTO   2FE
....................  
....................  
....................  
....................  
....................  
....................  
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... } 
0D09:  SLEEP

Configuration Fuses:
   Word  1: 2F43   RC NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
