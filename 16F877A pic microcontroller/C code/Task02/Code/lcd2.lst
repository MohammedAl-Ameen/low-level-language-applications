CCS PCM C Compiler, Version 5.015, 5967               18-Apr-21 14:28

               Filename:   C:\Users\Mohammed\Desktop\New folder (2)\lcd2.lst

               ROM used:   821 words (10%)
                           Largest free fragment is 2048
               RAM used:   51 (14%) at main() level
                           54 (15%) worst case
               Stack used: 2 locations
               Stack size: 8

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   21C
0003:  NOP
.................... #include "16F877A.h" 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  6D
0009:  RETLW  6F
000A:  RETLW  68
000B:  RETLW  61
000C:  RETLW  6D
000D:  RETLW  6D
000E:  RETLW  65
000F:  RETLW  64
0010:  RETLW  00
0011:  DATA D7,32
0012:  DATA EC,31
0013:  DATA EF,36
0014:  DATA 65,00
0015:  DATA 50,36
0016:  DATA E5,30
0017:  DATA F3,32
0018:  DATA A0,32
0019:  DATA 6E,3A
001A:  DATA 65,39
001B:  DATA A0,3C
001C:  DATA EF,3A
001D:  DATA 72,10
001E:  DATA F0,30
001F:  DATA F3,39
0020:  DATA F7,37
0021:  DATA 72,32
0022:  DATA 8D,06
0023:  DATA 00,00
0024:  DATA C7,37
0025:  DATA 6F,32
0026:  DATA 20,32
0027:  DATA E1,3C
0028:  DATA 00,00
0029:  DATA C7,37
002A:  DATA 6F,32
002B:  DATA 20,31
002C:  DATA F9,32
002D:  DATA 00,00
*
0065:  MOVF   0B,W
0066:  MOVWF  4C
0067:  BCF    0B.7
0068:  BSF    03.5
0069:  BSF    03.6
006A:  BSF    0C.7
006B:  BSF    0C.0
006C:  NOP
006D:  NOP
006E:  BCF    03.5
006F:  BCF    03.6
0070:  BTFSC  4C.7
0071:  BSF    0B.7
0072:  BSF    03.6
0073:  MOVF   0C,W
0074:  ANDLW  7F
0075:  BTFSC  03.2
0076:  GOTO   0B9
0077:  BCF    03.6
0078:  MOVWF  4C
0079:  BSF    03.6
007A:  MOVF   0D,W
007B:  BCF    03.6
007C:  MOVWF  4D
007D:  BSF    03.6
007E:  MOVF   0F,W
007F:  BCF    03.6
0080:  MOVWF  4E
0081:  MOVF   4C,W
0082:  MOVWF  4F
0083:  CALL   043
0084:  MOVF   4D,W
0085:  BSF    03.6
0086:  MOVWF  0D
0087:  BCF    03.6
0088:  MOVF   4E,W
0089:  BSF    03.6
008A:  MOVWF  0F
008B:  BCF    03.6
008C:  MOVF   0B,W
008D:  MOVWF  4F
008E:  BCF    0B.7
008F:  BSF    03.5
0090:  BSF    03.6
0091:  BSF    0C.7
0092:  BSF    0C.0
0093:  NOP
0094:  NOP
0095:  BCF    03.5
0096:  BCF    03.6
0097:  BTFSC  4F.7
0098:  BSF    0B.7
0099:  BSF    03.6
009A:  RLF    0C,W
009B:  RLF    0E,W
009C:  ANDLW  7F
009D:  BTFSC  03.2
009E:  GOTO   0B9
009F:  BCF    03.6
00A0:  MOVWF  4C
00A1:  BSF    03.6
00A2:  MOVF   0D,W
00A3:  BCF    03.6
00A4:  MOVWF  4D
00A5:  BSF    03.6
00A6:  MOVF   0F,W
00A7:  BCF    03.6
00A8:  MOVWF  4E
00A9:  MOVF   4C,W
00AA:  MOVWF  4F
00AB:  CALL   043
00AC:  MOVF   4D,W
00AD:  BSF    03.6
00AE:  MOVWF  0D
00AF:  BCF    03.6
00B0:  MOVF   4E,W
00B1:  BSF    03.6
00B2:  MOVWF  0F
00B3:  INCF   0D,F
00B4:  BTFSC  03.2
00B5:  INCF   0F,F
00B6:  BCF    03.6
00B7:  GOTO   065
00B8:  BSF    03.6
00B9:  BCF    03.6
00BA:  BCF    0A.3
00BB:  BCF    0A.4
00BC:  GOTO   261 (RETURN)
*
00DF:  MOVF   0B,W
00E0:  MOVWF  4C
00E1:  BCF    0B.7
00E2:  BSF    03.5
00E3:  BSF    03.6
00E4:  BSF    0C.7
00E5:  BSF    0C.0
00E6:  NOP
00E7:  NOP
00E8:  BCF    03.5
00E9:  BCF    03.6
00EA:  BTFSC  4C.7
00EB:  BSF    0B.7
00EC:  BSF    03.6
00ED:  MOVF   0C,W
00EE:  ANDLW  7F
00EF:  BTFSC  03.2
00F0:  GOTO   133
00F1:  BCF    03.6
00F2:  MOVWF  4C
00F3:  BSF    03.6
00F4:  MOVF   0D,W
00F5:  BCF    03.6
00F6:  MOVWF  4D
00F7:  BSF    03.6
00F8:  MOVF   0F,W
00F9:  BCF    03.6
00FA:  MOVWF  4E
00FB:  MOVF   4C,W
00FC:  MOVWF  4F
00FD:  CALL   0BD
00FE:  MOVF   4D,W
00FF:  BSF    03.6
0100:  MOVWF  0D
0101:  BCF    03.6
0102:  MOVF   4E,W
0103:  BSF    03.6
0104:  MOVWF  0F
0105:  BCF    03.6
0106:  MOVF   0B,W
0107:  MOVWF  4F
0108:  BCF    0B.7
0109:  BSF    03.5
010A:  BSF    03.6
010B:  BSF    0C.7
010C:  BSF    0C.0
010D:  NOP
010E:  NOP
010F:  BCF    03.5
0110:  BCF    03.6
0111:  BTFSC  4F.7
0112:  BSF    0B.7
0113:  BSF    03.6
0114:  RLF    0C,W
0115:  RLF    0E,W
0116:  ANDLW  7F
0117:  BTFSC  03.2
0118:  GOTO   133
0119:  BCF    03.6
011A:  MOVWF  4C
011B:  BSF    03.6
011C:  MOVF   0D,W
011D:  BCF    03.6
011E:  MOVWF  4D
011F:  BSF    03.6
0120:  MOVF   0F,W
0121:  BCF    03.6
0122:  MOVWF  4E
0123:  MOVF   4C,W
0124:  MOVWF  4F
0125:  CALL   0BD
0126:  MOVF   4D,W
0127:  BSF    03.6
0128:  MOVWF  0D
0129:  BCF    03.6
012A:  MOVF   4E,W
012B:  BSF    03.6
012C:  MOVWF  0F
012D:  INCF   0D,F
012E:  BTFSC  03.2
012F:  INCF   0F,F
0130:  BCF    03.6
0131:  GOTO   0DF
0132:  BSF    03.6
0133:  BCF    03.6
0134:  BCF    0A.3
0135:  BCF    0A.4
0136:  GOTO   282 (RETURN)
*
01C6:  MOVF   0B,W
01C7:  MOVWF  4C
01C8:  BCF    0B.7
01C9:  BSF    03.5
01CA:  BSF    03.6
01CB:  BSF    0C.7
01CC:  BSF    0C.0
01CD:  NOP
01CE:  NOP
01CF:  BCF    03.5
01D0:  BCF    03.6
01D1:  BTFSC  4C.7
01D2:  BSF    0B.7
01D3:  BSF    03.6
01D4:  MOVF   0C,W
01D5:  ANDLW  7F
01D6:  BTFSC  03.2
01D7:  GOTO   21A
01D8:  BCF    03.6
01D9:  MOVWF  4C
01DA:  BSF    03.6
01DB:  MOVF   0D,W
01DC:  BCF    03.6
01DD:  MOVWF  4D
01DE:  BSF    03.6
01DF:  MOVF   0F,W
01E0:  BCF    03.6
01E1:  MOVWF  4E
01E2:  MOVF   4C,W
01E3:  MOVWF  4F
01E4:  CALL   15E
01E5:  MOVF   4D,W
01E6:  BSF    03.6
01E7:  MOVWF  0D
01E8:  BCF    03.6
01E9:  MOVF   4E,W
01EA:  BSF    03.6
01EB:  MOVWF  0F
01EC:  BCF    03.6
01ED:  MOVF   0B,W
01EE:  MOVWF  4F
01EF:  BCF    0B.7
01F0:  BSF    03.5
01F1:  BSF    03.6
01F2:  BSF    0C.7
01F3:  BSF    0C.0
01F4:  NOP
01F5:  NOP
01F6:  BCF    03.5
01F7:  BCF    03.6
01F8:  BTFSC  4F.7
01F9:  BSF    0B.7
01FA:  BSF    03.6
01FB:  RLF    0C,W
01FC:  RLF    0E,W
01FD:  ANDLW  7F
01FE:  BTFSC  03.2
01FF:  GOTO   21A
0200:  BCF    03.6
0201:  MOVWF  4C
0202:  BSF    03.6
0203:  MOVF   0D,W
0204:  BCF    03.6
0205:  MOVWF  4D
0206:  BSF    03.6
0207:  MOVF   0F,W
0208:  BCF    03.6
0209:  MOVWF  4E
020A:  MOVF   4C,W
020B:  MOVWF  4F
020C:  CALL   15E
020D:  MOVF   4D,W
020E:  BSF    03.6
020F:  MOVWF  0D
0210:  BCF    03.6
0211:  MOVF   4E,W
0212:  BSF    03.6
0213:  MOVWF  0F
0214:  INCF   0D,F
0215:  BTFSC  03.2
0216:  INCF   0F,F
0217:  BCF    03.6
0218:  GOTO   1C6
0219:  BSF    03.6
021A:  BCF    03.6
021B:  RETURN
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0180:  MOVF   4D,W
0181:  MOVWF  7A
0182:  MOVF   4C,W
0183:  MOVWF  04
0184:  BCF    03.7
0185:  BTFSC  7A.0
0186:  BSF    03.7
0187:  MOVF   00,W
0188:  MOVWF  50
0189:  MOVF   4F,W
018A:  MOVWF  7A
018B:  MOVF   4E,W
018C:  MOVWF  04
018D:  BCF    03.7
018E:  BTFSC  7A.0
018F:  BSF    03.7
0190:  MOVF   00,W
0191:  SUBWF  50,W
0192:  BTFSS  03.2
0193:  GOTO   1AB
....................       if (*s1 == '\0') 
0194:  MOVF   4D,W
0195:  MOVWF  7A
0196:  MOVF   4C,W
0197:  MOVWF  04
0198:  BCF    03.7
0199:  BTFSC  7A.0
019A:  BSF    03.7
019B:  MOVF   00,F
019C:  BTFSS  03.2
019D:  GOTO   1A1
....................          return(0); 
019E:  MOVLW  00
019F:  MOVWF  78
01A0:  GOTO   1C3
01A1:  MOVF   4D,W
01A2:  MOVWF  7A
01A3:  MOVF   4C,W
01A4:  INCF   4C,F
01A5:  BTFSC  03.2
01A6:  INCF   4D,F
01A7:  INCF   4E,F
01A8:  BTFSC  03.2
01A9:  INCF   4F,F
01AA:  GOTO   180
....................    return((*s1 < *s2) ? -1: 1); 
01AB:  MOVF   4D,W
01AC:  MOVWF  7A
01AD:  MOVF   4C,W
01AE:  MOVWF  04
01AF:  BCF    03.7
01B0:  BTFSC  4D.0
01B1:  BSF    03.7
01B2:  MOVF   00,W
01B3:  MOVWF  50
01B4:  MOVF   4F,W
01B5:  MOVWF  7A
01B6:  MOVF   4E,W
01B7:  MOVWF  04
01B8:  BCF    03.7
01B9:  BTFSC  4F.0
01BA:  BSF    03.7
01BB:  MOVF   00,W
01BC:  SUBWF  50,W
01BD:  BTFSC  03.0
01BE:  GOTO   1C1
01BF:  MOVLW  FF
01C0:  GOTO   1C2
01C1:  MOVLW  01
01C2:  MOVWF  78
01C3:  BCF    0A.3
01C4:  BCF    0A.4
01C5:  GOTO   2A6 (RETURN)
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0237:  BCF    03.5
0238:  CLRF   20
0239:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #use delay(clock=4000000) 
*
002E:  MOVLW  4D
002F:  MOVWF  04
0030:  BCF    03.7
0031:  MOVF   00,W
0032:  BTFSC  03.2
0033:  GOTO   042
0034:  MOVLW  01
0035:  MOVWF  78
0036:  CLRF   77
0037:  DECFSZ 77,F
0038:  GOTO   037
0039:  DECFSZ 78,F
003A:  GOTO   036
003B:  MOVLW  4A
003C:  MOVWF  77
003D:  DECFSZ 77,F
003E:  GOTO   03D
003F:  GOTO   040
0040:  DECFSZ 00,F
0041:  GOTO   034
0042:  RETURN
.................... int n=8; 
.................... char string1[20]; 
.................... char string2[20]; 
.................... void main() 
*
021C:  MOVF   03,W
021D:  ANDLW  1F
021E:  MOVWF  03
021F:  MOVLW  08
0220:  MOVWF  22
0221:  BSF    03.5
0222:  BCF    08.0
0223:  BCF    03.5
0224:  BSF    08.0
0225:  BSF    03.5
0226:  BCF    06.0
0227:  BCF    03.5
0228:  BSF    06.0
0229:  BSF    03.5
022A:  BCF    08.0
022B:  BCF    03.5
022C:  BSF    08.0
022D:  MOVLW  FF
022E:  MOVWF  4B
022F:  BSF    03.5
0230:  BSF    1F.0
0231:  BSF    1F.1
0232:  BSF    1F.2
0233:  BCF    1F.3
0234:  MOVLW  07
0235:  MOVWF  1C
0236:  BCF    03.7
.................... { 
.................... strcpy (string1,"mohammed"); 
*
023A:  CLRF   4C
023B:  CLRF   4D
023C:  MOVLW  23
023D:  MOVWF  04
023E:  BCF    03.7
023F:  MOVF   4C,W
0240:  ADDWF  04,F
0241:  MOVF   4D,W
0242:  CALL   004
0243:  MOVWF  00
0244:  IORLW  00
0245:  BTFSC  03.2
0246:  GOTO   24A
0247:  INCF   4D,F
0248:  INCF   4C,F
0249:  GOTO   23C
....................  
.................... #use rs232(baud=9600, xmit=PIN_D0, rcv=PIN_D1) 
*
0043:  BSF    03.5
0044:  BCF    08.0
0045:  BCF    03.5
0046:  BCF    08.0
0047:  MOVLW  08
0048:  MOVWF  78
0049:  GOTO   04A
004A:  NOP
004B:  BSF    78.7
004C:  GOTO   05B
004D:  BCF    78.7
004E:  RRF    4F,F
004F:  BTFSC  03.0
0050:  BSF    08.0
0051:  BTFSS  03.0
0052:  BCF    08.0
0053:  BSF    78.6
0054:  GOTO   05B
0055:  BCF    78.6
0056:  DECFSZ 78,F
0057:  GOTO   04E
0058:  GOTO   059
0059:  NOP
005A:  BSF    08.0
005B:  MOVLW  1C
005C:  MOVWF  04
005D:  DECFSZ 04,F
005E:  GOTO   05D
005F:  GOTO   060
0060:  BTFSC  78.7
0061:  GOTO   04D
0062:  BTFSC  78.6
0063:  GOTO   055
0064:  RETURN
.................... delay_ms(1000);    // Wait for LCD to wake up 
*
024A:  MOVLW  04
024B:  MOVWF  4C
024C:  MOVLW  FA
024D:  MOVWF  4D
024E:  CALL   02E
024F:  DECFSZ 4C,F
0250:  GOTO   24C
....................  
.................... putc(254); putc(1);    // clear the screen 
0251:  MOVLW  FE
0252:  MOVWF  4F
0253:  CALL   043
0254:  MOVLW  01
0255:  MOVWF  4F
0256:  CALL   043
.................... delay_ms(10);   // Wait for LCD to finish 
0257:  MOVLW  0A
0258:  MOVWF  4D
0259:  CALL   02E
.................... printf("Welcome"); 
025A:  MOVLW  11
025B:  BSF    03.6
025C:  MOVWF  0D
025D:  MOVLW  00
025E:  MOVWF  0F
025F:  BCF    03.6
0260:  GOTO   065
.................... //PRINTF(string1);    // Send test character 
.................... for (n='3';n>='0';n--) 
0261:  MOVLW  33
0262:  MOVWF  22
0263:  MOVF   22,W
0264:  SUBLW  2F
0265:  BTFSC  03.0
0266:  GOTO   275
....................    {   output_a(n); 
0267:  BSF    03.5
0268:  CLRF   05
0269:  BCF    03.5
026A:  MOVF   22,W
026B:  MOVWF  05
....................     //  printf("\a"); 
....................       delay_ms(1000); 
026C:  MOVLW  04
026D:  MOVWF  4C
026E:  MOVLW  FA
026F:  MOVWF  4D
0270:  CALL   02E
0271:  DECFSZ 4C,F
0272:  GOTO   26E
0273:  DECF   22,F
0274:  GOTO   263
....................    } 
.................... putc(254); putc(1); 
0275:  MOVLW  FE
0276:  MOVWF  4F
0277:  CALL   043
0278:  MOVLW  01
0279:  MOVWF  4F
027A:  CALL   043
.................... //putc(254); putc(192); delay_ms(10);   // Move to second row 
....................  
....................  
.................... #use rs232(baud=9600, xmit=PIN_B0, rcv=PIN_B1) 
*
00BD:  BSF    03.5
00BE:  BCF    06.0
00BF:  BCF    03.5
00C0:  BCF    06.0
00C1:  MOVLW  08
00C2:  MOVWF  78
00C3:  GOTO   0C4
00C4:  NOP
00C5:  BSF    78.7
00C6:  GOTO   0D5
00C7:  BCF    78.7
00C8:  RRF    4F,F
00C9:  BTFSC  03.0
00CA:  BSF    06.0
00CB:  BTFSS  03.0
00CC:  BCF    06.0
00CD:  BSF    78.6
00CE:  GOTO   0D5
00CF:  BCF    78.6
00D0:  DECFSZ 78,F
00D1:  GOTO   0C8
00D2:  GOTO   0D3
00D3:  NOP
00D4:  BSF    06.0
00D5:  MOVLW  1C
00D6:  MOVWF  04
00D7:  DECFSZ 04,F
00D8:  GOTO   0D7
00D9:  GOTO   0DA
00DA:  BTFSC  78.7
00DB:  GOTO   0C7
00DC:  BTFSC  78.6
00DD:  GOTO   0CF
00DE:  RETURN
*
0137:  BSF    03.5
0138:  BSF    06.1
0139:  BCF    03.5
013A:  BTFSC  06.1
013B:  GOTO   13A
013C:  MOVLW  08
013D:  MOVWF  77
013E:  CLRF   4C
013F:  BSF    77.7
0140:  GOTO   14F
0141:  BCF    77.7
0142:  GOTO   14F
0143:  BCF    03.0
0144:  BTFSC  06.1
0145:  BSF    03.0
0146:  RRF    4C,F
0147:  BSF    77.6
0148:  GOTO   14F
0149:  BCF    77.6
014A:  DECFSZ 77,F
014B:  GOTO   143
014C:  MOVF   4C,W
014D:  MOVWF  78
014E:  GOTO   15B
014F:  MOVLW  1C
0150:  BTFSC  77.7
0151:  MOVLW  07
0152:  MOVWF  78
0153:  DECFSZ 78,F
0154:  GOTO   153
0155:  NOP
0156:  BTFSC  77.7
0157:  GOTO   141
0158:  BTFSC  77.6
0159:  GOTO   149
015A:  GOTO   143
015B:  BCF    0A.3
015C:  BCF    0A.4
015D:  GOTO   288 (RETURN)
.................... PRINTF("Please enter your password\r\r" ); 
*
027B:  MOVLW  15
027C:  BSF    03.6
027D:  MOVWF  0D
027E:  MOVLW  00
027F:  MOVWF  0F
0280:  BCF    03.6
0281:  GOTO   0DF
.................... gets(string2); 
0282:  MOVLW  37
0283:  MOVWF  04
0284:  BCF    03.7
0285:  DECF   04,F
0286:  INCF   04,F
0287:  GOTO   137
0288:  MOVF   78,W
0289:  MOVWF  00
028A:  MOVLW  0D
028B:  SUBWF  00,W
028C:  BTFSS  03.2
028D:  GOTO   286
028E:  CLRF   00
.................... #use rs232(baud=9600, xmit=PIN_D0, rcv=PIN_D1) 
*
015E:  BSF    03.5
015F:  BCF    08.0
0160:  BCF    03.5
0161:  BCF    08.0
0162:  MOVLW  08
0163:  MOVWF  78
0164:  GOTO   165
0165:  NOP
0166:  BSF    78.7
0167:  GOTO   176
0168:  BCF    78.7
0169:  RRF    4F,F
016A:  BTFSC  03.0
016B:  BSF    08.0
016C:  BTFSS  03.0
016D:  BCF    08.0
016E:  BSF    78.6
016F:  GOTO   176
0170:  BCF    78.6
0171:  DECFSZ 78,F
0172:  GOTO   169
0173:  GOTO   174
0174:  NOP
0175:  BSF    08.0
0176:  MOVLW  1C
0177:  MOVWF  04
0178:  DECFSZ 04,F
0179:  GOTO   178
017A:  GOTO   17B
017B:  BTFSC  78.7
017C:  GOTO   168
017D:  BTFSC  78.6
017E:  GOTO   170
017F:  RETURN
.................... delay_ms(1000); 
*
028F:  MOVLW  04
0290:  MOVWF  4C
0291:  MOVLW  FA
0292:  MOVWF  4D
0293:  CALL   02E
0294:  DECFSZ 4C,F
0295:  GOTO   291
.................... putc(254); putc(1); 
0296:  MOVLW  FE
0297:  MOVWF  4F
0298:  CALL   15E
0299:  MOVLW  01
029A:  MOVWF  4F
029B:  CALL   15E
.................... delay_ms(10); 
029C:  MOVLW  0A
029D:  MOVWF  4D
029E:  CALL   02E
.................... if (strcmp(string2,string1)==0){ 
029F:  CLRF   4D
02A0:  MOVLW  37
02A1:  MOVWF  4C
02A2:  CLRF   4F
02A3:  MOVLW  23
02A4:  MOVWF  4E
02A5:  GOTO   180
02A6:  MOVF   78,F
02A7:  BTFSS  03.2
02A8:  GOTO   32D
....................  
.................... printf("Good day"); 
02A9:  MOVLW  24
02AA:  BSF    03.6
02AB:  MOVWF  0D
02AC:  MOVLW  00
02AD:  MOVWF  0F
02AE:  BCF    03.6
02AF:  CALL   1C6
.................... //for (n = 0 ;n < 9;n++){ 
.................... //int counter; 
.................... //counter = 2^n; 
.................... output_c(1); 
02B0:  MOVLW  00
02B1:  MOVWF  4B
02B2:  BSF    03.5
02B3:  CLRF   07
02B4:  MOVLW  01
02B5:  BCF    03.5
02B6:  MOVWF  07
.................... delay_ms(1000); 
02B7:  MOVLW  04
02B8:  MOVWF  4C
02B9:  MOVLW  FA
02BA:  MOVWF  4D
02BB:  CALL   02E
02BC:  DECFSZ 4C,F
02BD:  GOTO   2B9
.................... output_c(2); 
02BE:  MOVLW  00
02BF:  MOVWF  4B
02C0:  BSF    03.5
02C1:  CLRF   07
02C2:  MOVLW  02
02C3:  BCF    03.5
02C4:  MOVWF  07
.................... delay_ms(1000); 
02C5:  MOVLW  04
02C6:  MOVWF  4C
02C7:  MOVLW  FA
02C8:  MOVWF  4D
02C9:  CALL   02E
02CA:  DECFSZ 4C,F
02CB:  GOTO   2C7
.................... output_c(4); 
02CC:  MOVLW  00
02CD:  MOVWF  4B
02CE:  BSF    03.5
02CF:  CLRF   07
02D0:  MOVLW  04
02D1:  BCF    03.5
02D2:  MOVWF  07
.................... delay_ms(1000); 
02D3:  MOVWF  4C
02D4:  MOVLW  FA
02D5:  MOVWF  4D
02D6:  CALL   02E
02D7:  DECFSZ 4C,F
02D8:  GOTO   2D4
.................... output_c(8); 
02D9:  MOVLW  00
02DA:  MOVWF  4B
02DB:  BSF    03.5
02DC:  CLRF   07
02DD:  MOVLW  08
02DE:  BCF    03.5
02DF:  MOVWF  07
.................... delay_ms(1000); 
02E0:  MOVLW  04
02E1:  MOVWF  4C
02E2:  MOVLW  FA
02E3:  MOVWF  4D
02E4:  CALL   02E
02E5:  DECFSZ 4C,F
02E6:  GOTO   2E2
.................... output_c(16); 
02E7:  MOVLW  00
02E8:  MOVWF  4B
02E9:  BSF    03.5
02EA:  CLRF   07
02EB:  MOVLW  10
02EC:  BCF    03.5
02ED:  MOVWF  07
.................... delay_ms(1000); 
02EE:  MOVLW  04
02EF:  MOVWF  4C
02F0:  MOVLW  FA
02F1:  MOVWF  4D
02F2:  CALL   02E
02F3:  DECFSZ 4C,F
02F4:  GOTO   2F0
.................... output_c(32); 
02F5:  MOVLW  00
02F6:  MOVWF  4B
02F7:  BSF    03.5
02F8:  CLRF   07
02F9:  MOVLW  20
02FA:  BCF    03.5
02FB:  MOVWF  07
.................... delay_ms(1000); 
02FC:  MOVLW  04
02FD:  MOVWF  4C
02FE:  MOVLW  FA
02FF:  MOVWF  4D
0300:  CALL   02E
0301:  DECFSZ 4C,F
0302:  GOTO   2FE
.................... output_c(64); 
0303:  MOVLW  00
0304:  MOVWF  4B
0305:  BSF    03.5
0306:  CLRF   07
0307:  MOVLW  40
0308:  BCF    03.5
0309:  MOVWF  07
.................... delay_ms(1000); 
030A:  MOVLW  04
030B:  MOVWF  4C
030C:  MOVLW  FA
030D:  MOVWF  4D
030E:  CALL   02E
030F:  DECFSZ 4C,F
0310:  GOTO   30C
.................... output_c(128); 
0311:  MOVLW  00
0312:  MOVWF  4B
0313:  BSF    03.5
0314:  CLRF   07
0315:  MOVLW  80
0316:  BCF    03.5
0317:  MOVWF  07
.................... delay_ms(1000); 
0318:  MOVLW  04
0319:  MOVWF  4C
031A:  MOVLW  FA
031B:  MOVWF  4D
031C:  CALL   02E
031D:  DECFSZ 4C,F
031E:  GOTO   31A
.................... output_c(256); 
031F:  MOVLW  00
0320:  MOVWF  4B
0321:  BSF    03.5
0322:  CLRF   07
0323:  BCF    03.5
0324:  CLRF   07
.................... delay_ms(1000); 
0325:  MOVLW  04
0326:  MOVWF  4C
0327:  MOVLW  FA
0328:  MOVWF  4D
0329:  CALL   02E
032A:  DECFSZ 4C,F
032B:  GOTO   327
....................  
....................  
.................... //} 
....................  
.................... } 
032C:  GOTO   334
.................... else  
.................... printf("Good bye"); 
032D:  MOVLW  29
032E:  BSF    03.6
032F:  MOVWF  0D
0330:  MOVLW  00
0331:  MOVWF  0F
0332:  BCF    03.6
0333:  CALL   1C6
....................       } 
....................  
0334:  SLEEP

Configuration Fuses:
   Word  1: 3F73   RC NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
